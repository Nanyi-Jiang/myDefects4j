Bug ID,ExceptionType,Repair Pattern,Buggy Lines,Fixed Lines,Combined Lines
Chart 6,junit.framework.AssertionFailedError,"condBlockRetAdd
wrongComp",-        return super.equals(obj);,"+        ShapeList that = (ShapeList) obj;
+        int listSize = size();
+        for (int i = 0; i < listSize; i++) {
+           if (!ShapeUtilities.equal((Shape) get(i), (Shape) that.get(i))) {
+               return false;
+           }
+        }
+        return true;","-        return super.equals(obj);
+        ShapeList that = (ShapeList) obj;
+        int listSize = size();
+        for (int i = 0; i < listSize; i++) {
+           if (!ShapeUtilities.equal((Shape) get(i), (Shape) that.get(i))) {
+               return false;
+           }
+        }
+        return true;"
Chart 10,junit.framework.ComparisonFailure,"singleLine
wrapsMethod","-        return "" title=\"""" + toolTipText","+        return "" title=\"""" + ImageMapUtilities.htmlEscape(toolTipText) ","-        return "" title=\"""" + toolTipText
+        return "" title=\"""" + ImageMapUtilities.htmlEscape(toolTipText) "
Chart 9,java.lang.IllegalArgumentException,"expLogicExpand
singleLine","-        if (endIndex < 0) {","+        if ((endIndex < 0)  || (endIndex < startIndex)) {","-        if (endIndex < 0) {
+        if ((endIndex < 0)  || (endIndex < startIndex)) {"
Chart 8,junit.framework.AssertionFailedError,"initFix
singleLine
wrongVarRef","-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());","+        this(time, zone, Locale.getDefault());","-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());
+        this(time, zone, Locale.getDefault());"
Chart 7,junit.framework.AssertionFailedError,"copyPaste
expArithMod
wrongVarRef","-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()
-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()","+            long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()
+            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()","-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()
+            long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()
-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()
+            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()"
Chart 5,java.lang.IndexOutOfBoundsException,"condBlockRetAdd
expLogicReduce","-        if (index >= 0 && !this.allowDuplicateXValues) {","+        if (this.allowDuplicateXValues) {
+            add(x, y);
+            return null;
+        }
+        if (index >= 0) {","+        if (this.allowDuplicateXValues) {
+            add(x, y);
+            return null;
+        }
-        if (index >= 0 && !this.allowDuplicateXValues) {
+        if (index >= 0) {"
Chart 3,junit.framework.AssertionFailedError,"initFix
notClassified",,"+        copy.minY = Double.NaN;
+        copy.maxY = Double.NaN;","+        copy.minY = Double.NaN;
+        copy.maxY = Double.NaN;"
Chart 4,java.lang.NullPointerException,"missNullCheckN
wrapsIf",,"+                if (r != null) {
+                }","+                if (r != null) {
+                }"
Chart 2,java.lang.NullPointerException,"condBlockOthersAdd
copyPaste
missComp",,"+                    double value = intervalXYData.getXValue(series, item);
+                    if (!Double.isNaN(value)) {
+                        minimum = Math.min(minimum, value);
+                        maximum = Math.max(maximum, value);
+                    }
+                        maximum = Math.max(maximum, lvalue);
+                        minimum = Math.min(minimum, uvalue);
+                    double value = ixyd.getYValue(series, item);
+                    if (!Double.isNaN(value)) {
+                        minimum = Math.min(minimum, value);
+                        maximum = Math.max(maximum, value);
+                    }
+                        maximum = Math.max(maximum, lvalue);
+                        minimum = Math.min(minimum, uvalue);","+                    double value = intervalXYData.getXValue(series, item);
+                    if (!Double.isNaN(value)) {
+                        minimum = Math.min(minimum, value);
+                        maximum = Math.max(maximum, value);
+                    }
+                        maximum = Math.max(maximum, lvalue);
+                        minimum = Math.min(minimum, uvalue);
+                    double value = ixyd.getYValue(series, item);
+                    if (!Double.isNaN(value)) {
+                        minimum = Math.min(minimum, value);
+                        maximum = Math.max(maximum, value);
+                    }
+                        maximum = Math.max(maximum, lvalue);
+                        minimum = Math.min(minimum, uvalue);"
Chart 1,junit.framework.AssertionFailedError,"expLogicMod
singleLine","-        if (dataset != null) {","+        if (dataset == null) {","-        if (dataset != null) {
+        if (dataset == null) {"
Chart 12,junit.framework.AssertionFailedError,"singleLine
wrapsMethod
wrongVarRef","-        this.dataset = dataset;","+        setDataset(dataset);","-        this.dataset = dataset;
+        setDataset(dataset);"
Chart 11,junit.framework.AssertionFailedError,"singleLine
wrongComp
wrongVarRef",-        PathIterator iterator2 = p1.getPathIterator(null);,+        PathIterator iterator2 = p2.getPathIterator(null);,"-        PathIterator iterator2 = p1.getPathIterator(null);
+        PathIterator iterator2 = p2.getPathIterator(null);"
Chart 13,java.lang.IllegalArgumentException,"initFix
missComp
singleLine
wrapsMethod
wrongMethodRef","-                    new Range(0.0, constraint.getWidth() - w[2]),","+                    new Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)),","-                    new Range(0.0, constraint.getWidth() - w[2]),
+                    new Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)),"
Chart 18,java.lang.IndexOutOfBoundsException,"condBlockExcAdd
missNullCheckP
unwrapIfElse
wrapsIf","-        if (index < this.keys.size()) {
-        }","+            throw new UnknownKeyException(""The key ("" + key 
+                    + "") is not recognised."");
+    	if (columnKey == null) {
+    		throw new IllegalArgumentException(""Null 'columnKey' argument."");
+    	}
+    	if (!this.columnKeys.contains(columnKey)) {
+    		throw new UnknownKeyException(""Unknown key: "" + columnKey);
+    	}
+            int index = rowData.getIndex(columnKey);
+            if (index >= 0) {
+            }","-        if (index < this.keys.size()) {
-        }
+            throw new UnknownKeyException(""The key ("" + key 
+                    + "") is not recognised."");
+    	if (columnKey == null) {
+    		throw new IllegalArgumentException(""Null 'columnKey' argument."");
+    	}
+    	if (!this.columnKeys.contains(columnKey)) {
+    		throw new UnknownKeyException(""Unknown key: "" + columnKey);
+    	}
+            int index = rowData.getIndex(columnKey);
+            if (index >= 0) {
+            }"
Chart 14,java.lang.NullPointerException,"condBlockRetAdd
copyPaste
missNullCheckP",,"+        if (markers == null) {
+            return false;
+        }
+        if (markers == null) {
+            return false;
+        }
+        if (markers == null) {
+            return false;
+        }
+        if (markers == null) {
+            return false;
+        }","+        if (markers == null) {
+            return false;
+        }
+        if (markers == null) {
+            return false;
+        }
+        if (markers == null) {
+            return false;
+        }
+        if (markers == null) {
+            return false;
+        }"
Chart 21,junit.framework.AssertionFailedError,"condBlockOthersAdd
missComp
wrapsElse",,"+        else {
+        }
+        this.minimumRangeValueRow = -1;
+        this.minimumRangeValueColumn = -1;
+        this.maximumRangeValueRow = -1;
+        this.maximumRangeValueColumn = -1;
+        int rowCount = getRowCount();
+        int columnCount = getColumnCount();
+        for (int r = 0; r < rowCount; r++) {
+            for (int c = 0; c < columnCount; c++) {
+                BoxAndWhiskerItem item = getItem(r, c);
+                if (item != null) {
+                    Number min = item.getMinOutlier();
+                    if (min != null) {
+                        double minv = min.doubleValue();
+                        if (!Double.isNaN(minv)) {
+                            if (minv < this.minimumRangeValue || Double.isNaN(
+                                    this.minimumRangeValue)) {
+                                this.minimumRangeValue = minv;
+                                this.minimumRangeValueRow = r;
+                                this.minimumRangeValueColumn = c;
+                            }
+                        }
+                    }
+                    Number max = item.getMaxOutlier();
+                    if (max != null) {
+                        double maxv = max.doubleValue();
+                        if (!Double.isNaN(maxv)) {
+                            if (maxv > this.maximumRangeValue || Double.isNaN(
+                                    this.maximumRangeValue)) {
+                                this.maximumRangeValue = maxv;
+                                this.maximumRangeValueRow = r;
+                                this.maximumRangeValueColumn = c;
+                            }
+                        }
+                    }
+                }
+            }
+        }","+        else {
+        }
+        this.minimumRangeValueRow = -1;
+        this.minimumRangeValueColumn = -1;
+        this.maximumRangeValueRow = -1;
+        this.maximumRangeValueColumn = -1;
+        int rowCount = getRowCount();
+        int columnCount = getColumnCount();
+        for (int r = 0; r < rowCount; r++) {
+            for (int c = 0; c < columnCount; c++) {
+                BoxAndWhiskerItem item = getItem(r, c);
+                if (item != null) {
+                    Number min = item.getMinOutlier();
+                    if (min != null) {
+                        double minv = min.doubleValue();
+                        if (!Double.isNaN(minv)) {
+                            if (minv < this.minimumRangeValue || Double.isNaN(
+                                    this.minimumRangeValue)) {
+                                this.minimumRangeValue = minv;
+                                this.minimumRangeValueRow = r;
+                                this.minimumRangeValueColumn = c;
+                            }
+                        }
+                    }
+                    Number max = item.getMaxOutlier();
+                    if (max != null) {
+                        double maxv = max.doubleValue();
+                        if (!Double.isNaN(maxv)) {
+                            if (maxv > this.maximumRangeValue || Double.isNaN(
+                                    this.maximumRangeValue)) {
+                                this.maximumRangeValue = maxv;
+                                this.maximumRangeValueRow = r;
+                                this.maximumRangeValueColumn = c;
+                            }
+                        }
+                    }
+                }
+            }
+        }"
Chart 15,junit.framework.AssertionFailedError,"condBlockRetAdd
missNullCheckN
missNullCheckP
wrapsIf",,"+        if (this.dataset == null) {
+            return 0.0;
+        }
+        if (this.dataset != null) {
+        }","+        if (this.dataset == null) {
+            return 0.0;
+        }
+        if (this.dataset != null) {
+        }"
Chart 16,java.lang.NullPointerException,"expLogicMod
initFix
wrongVarRef","-                this.seriesKeys = null;
-                this.categoryKeys = null;
-        if (categoryKeys.length != this.startData[0].length) {","+                this.seriesKeys = new Comparable[0];
+                this.categoryKeys = new Comparable[0];
+        if (categoryKeys.length != getCategoryCount()) {","-                this.seriesKeys = null;
-                this.categoryKeys = null;
+                this.seriesKeys = new Comparable[0];
+                this.categoryKeys = new Comparable[0];
-        if (categoryKeys.length != this.startData[0].length) {
+        if (categoryKeys.length != getCategoryCount()) {"
Chart 17,java.lang.IllegalArgumentException,"notClassified
wrongComp","-        Object clone = createCopy(0, getItemCount() - 1);","+        TimeSeries clone = (TimeSeries) super.clone();
+        clone.data = (List) ObjectUtilities.deepClone(this.data);","-        Object clone = createCopy(0, getItemCount() - 1);
+        TimeSeries clone = (TimeSeries) super.clone();
+        clone.data = (List) ObjectUtilities.deepClone(this.data);"
Chart 20,junit.framework.AssertionFailedError,"initFix
singleLine
wrongVarRef","-        super(paint, stroke, paint, stroke, alpha);","+        super(paint, stroke, outlinePaint, outlineStroke, alpha);","-        super(paint, stroke, paint, stroke, alpha);
+        super(paint, stroke, outlinePaint, outlineStroke, alpha);"
Chart 19,junit.framework.AssertionFailedError,"condBlockExcAdd
copyPaste
missNullCheckP",,"+        if (axis == null) {
+            throw new IllegalArgumentException(""Null 'axis' argument."");
+        }
+        if (axis == null) {
+            throw new IllegalArgumentException(""Null 'axis' argument."");
+        }","+        if (axis == null) {
+            throw new IllegalArgumentException(""Null 'axis' argument."");
+        }
+        if (axis == null) {
+            throw new IllegalArgumentException(""Null 'axis' argument."");
+        }"
Chart 22,org.jfree.data.UnknownKeyException,"condBlockExcAdd
condBlockOthersAdd
missComp
unwrapIfElse
wrongVarRef","-        if (row >= 0) {
-            return rowData.getObject(columnKey);
-                rowData.removeValue(columnKey);","+        int index = rowData.getIndex(columnKey);
+        if (index >= 0) {
+            return rowData.getObject(index);
+        allNull = true;
+        for (int item = 0, itemCount = this.rows.size(); item < itemCount; 
+             item++) {
+            row = (KeyedObjects) this.rows.get(item);
+            int columnIndex = row.getIndex(columnKey);
+            if (columnIndex >= 0 && row.getObject(columnIndex) != null) {
+                allNull = false;
+                break;
+            }
+        }
+        if (allNull) {
+            for (int item = 0, itemCount = this.rows.size(); item < itemCount; 
+                 item++) {
+                row = (KeyedObjects) this.rows.get(item);
+                int columnIndex = row.getIndex(columnKey);
+                if (columnIndex >= 0) {
+                    row.removeValue(columnIndex);
+                }
+            }
+            this.columnKeys.remove(columnKey);
+        }
+        if (index < 0) {
+            throw new UnknownKeyException(""Row key ("" + rowKey 
+                    + "") not recognised."");
+        }
+            int i = rowData.getIndex(columnKey);
+            if (i >= 0) {
+                rowData.removeValue(i);
+            }","-        if (row >= 0) {
-            return rowData.getObject(columnKey);
+        int index = rowData.getIndex(columnKey);
+        if (index >= 0) {
+            return rowData.getObject(index);
+        allNull = true;
+        for (int item = 0, itemCount = this.rows.size(); item < itemCount; 
+             item++) {
+            row = (KeyedObjects) this.rows.get(item);
+            int columnIndex = row.getIndex(columnKey);
+            if (columnIndex >= 0 && row.getObject(columnIndex) != null) {
+                allNull = false;
+                break;
+            }
+        }
+        if (allNull) {
+            for (int item = 0, itemCount = this.rows.size(); item < itemCount; 
+                 item++) {
+                row = (KeyedObjects) this.rows.get(item);
+                int columnIndex = row.getIndex(columnKey);
+                if (columnIndex >= 0) {
+                    row.removeValue(columnIndex);
+                }
+            }
+            this.columnKeys.remove(columnKey);
+        }
+        if (index < 0) {
+            throw new UnknownKeyException(""Row key ("" + rowKey 
+                    + "") not recognised."");
+        }
-                rowData.removeValue(columnKey);
+            int i = rowData.getIndex(columnKey);
+            if (i >= 0) {
+                rowData.removeValue(i);
+            }"
Chart 26,junit.framework.AssertionFailedError,"missNullCheckN
wrapsIf",,"+            if (owner != null) {
+            }","+            if (owner != null) {
+            }"
Chart 25,junit.framework.AssertionFailedError,"condBlockRetAdd
copyPaste
missNullCheckN
missNullCheckP
wrapsIf
wrongComp","-            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();
-            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();","+        if (meanValue == null) {
+            return;
+        }
+        Number n = dataset.getStdDevValue(row, column);
+        if (n != null) {
+            double valueDelta = n.doubleValue();
+        }
+        if (meanValue == null) {
+            return;
+        }
+        Number n = dataset.getStdDevValue(row, column);
+        if (n != null) {
+            double valueDelta = n.doubleValue();
+        }","+        if (meanValue == null) {
+            return;
+        }
-            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();
+        Number n = dataset.getStdDevValue(row, column);
+        if (n != null) {
+            double valueDelta = n.doubleValue();
+        }
+        if (meanValue == null) {
+            return;
+        }
-            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();
+        Number n = dataset.getStdDevValue(row, column);
+        if (n != null) {
+            double valueDelta = n.doubleValue();
+        }"
Chart 23,junit.framework.AssertionFailedError,"condBlockRetAdd
wrongComp",,"+    public boolean equals(Object obj) {
+        if (obj == this) {
+            return true;
+        }
+        if (!(obj instanceof MinMaxCategoryRenderer)) {
+            return false;
+        }
+        MinMaxCategoryRenderer that = (MinMaxCategoryRenderer) obj;
+        if (this.plotLines != that.plotLines) {
+            return false;
+        }
+        if (!PaintUtilities.equal(this.groupPaint, that.groupPaint)) {
+            return false;
+        }
+        if (!this.groupStroke.equals(that.groupStroke)) {
+            return false;
+        }
+        return super.equals(obj);
+    }","+    public boolean equals(Object obj) {
+        if (obj == this) {
+            return true;
+        }
+        if (!(obj instanceof MinMaxCategoryRenderer)) {
+            return false;
+        }
+        MinMaxCategoryRenderer that = (MinMaxCategoryRenderer) obj;
+        if (this.plotLines != that.plotLines) {
+            return false;
+        }
+        if (!PaintUtilities.equal(this.groupPaint, that.groupPaint)) {
+            return false;
+        }
+        if (!this.groupStroke.equals(that.groupStroke)) {
+            return false;
+        }
+        return super.equals(obj);
+    }"
Chart 24,java.lang.IllegalArgumentException,"expArithMod
singleLine
wrongComp
wrongVarRef","-        int g = (int) ((value - this.lowerBound) / (this.upperBound ","+        int g = (int) ((v - this.lowerBound) / (this.upperBound ","-        int g = (int) ((value - this.lowerBound) / (this.upperBound 
+        int g = (int) ((v - this.lowerBound) / (this.upperBound "
Closure 3,junit.framework.AssertionFailedError,"condBlockOthersAdd
condBlockRetAdd","-      if (c.canInline()) {
-    private boolean canInline() {","+      if (c.canInline(t.getScope())) {
+    private boolean canInline(final Scope scope) {
+                  case Token.NAME:
+                    Var var = scope.getOwnSlot(input.getString());
+                    if (var != null
+                        && var.getParentNode().isCatch()) {
+                      return true;
+                    }","-      if (c.canInline()) {
+      if (c.canInline(t.getScope())) {
-    private boolean canInline() {
+    private boolean canInline(final Scope scope) {
+                  case Token.NAME:
+                    Var var = scope.getOwnSlot(input.getString());
+                    if (var != null
+                        && var.getParentNode().isCatch()) {
+                      return true;
+                    }"
Closure 7,junit.framework.AssertionFailedError,"condBlockRetAdd
expLogicReduce
wrongComp",-        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;,"+        if (resultEqualsValue) {
+          return ctorType.getGreatestSubtype(type);
+        } else {
+          return type.isSubtype(ctorType) ? null : type;
+        }","-        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;
+        if (resultEqualsValue) {
+          return ctorType.getGreatestSubtype(type);
+        } else {
+          return type.isSubtype(ctorType) ? null : type;
+        }"
Closure 5,junit.framework.AssertionFailedError,condBlockRetAdd,,"+          if (gramps.isDelProp()) {
+            return false;
+          }","+          if (gramps.isDelProp()) {
+            return false;
+          }"
Closure 6,junit.framework.AssertionFailedError,"copyPaste
unwrapIfElse","-      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {
-        registerMismatch(rightType, leftType, null);
-      } else {
-      }
-      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {
-        registerMismatch(rightType, leftType, null);
-      } else {
-      }",,"-      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {
-        registerMismatch(rightType, leftType, null);
-      } else {
-      }
-      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {
-        registerMismatch(rightType, leftType, null);
-      } else {
-      }"
Closure 2,java.lang.NullPointerException,"missNullCheckP
wrapsIfElse",,"+    if (implicitProto == null) {
+      currentPropertyNames = ImmutableSet.of();
+    } else {
+    }","+    if (implicitProto == null) {
+      currentPropertyNames = ImmutableSet.of();
+    } else {
+    }"
Closure 1,junit.framework.AssertionFailedError,condBlockRetAdd,,"+    if (!removeGlobals) {
+      return;
+    }","+    if (!removeGlobals) {
+      return;
+    }"
Closure 4,junit.framework.AssertionFailedError,"copyPaste
expLogicMod
wrongMethodRef","-    if (detectImplicitPrototypeCycle()) {
-    if (detectImplicitPrototypeCycle()) {","+    if (detectInheritanceCycle()) {
+    if (detectInheritanceCycle()) {","-    if (detectImplicitPrototypeCycle()) {
+    if (detectInheritanceCycle()) {
-    if (detectImplicitPrototypeCycle()) {
+    if (detectInheritanceCycle()) {"
Closure 8,junit.framework.AssertionFailedError,expLogicExpand,,"+          && !isNamedParameter(var)
+  private boolean isNamedParameter(Var v) {
+    return v.getParentNode().isParamList();
+  }","+          && !isNamedParameter(var)
+  private boolean isNamedParameter(Var v) {
+    return v.getParentNode().isParamList();
+  }"
Closure 9,junit.framework.ComparisonFailure,"missComp
unwrapMethod",-      String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));,"+    filename = filename.replace(""\\"", ""/"");
+      String moduleName = guessCJSModuleName(script.getSourceFileName());","+    filename = filename.replace(""\\"", ""/"");
-      String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));
+      String moduleName = guessCJSModuleName(script.getSourceFileName());"
Closure 11,junit.framework.AssertionFailedError,condBlockRem,"-    } else if (n.getJSType() != null && parent.isAssign()) {
-      return;",,"-    } else if (n.getJSType() != null && parent.isAssign()) {
-      return;"
Closure 12,junit.framework.AssertionFailedError,"condBlockRetAdd
missComp",,"+    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);
+    for (DiGraphEdge<Node, Branch> edge : branchEdges) {
+      if (edge.getValue() == Branch.ON_EX) {
+        return true;
+      }
+    }","+    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);
+    for (DiGraphEdge<Node, Branch> edge : branchEdges) {
+      if (edge.getValue() == Branch.ON_EX) {
+        return true;
+      }
+    }"
Closure 10,junit.framework.AssertionFailedError,"singleLine
wrongMethodRef","-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);","+      return anyResultsMatch(n, MAY_BE_STRING_PREDICATE);","-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);
+      return anyResultsMatch(n, MAY_BE_STRING_PREDICATE);"
Closure 14,junit.framework.AssertionFailedError,"constChange
singleLine
wrongVarRef","-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);","+              cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);","-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);
+              cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);"
Closure 17,junit.framework.ComparisonFailure,"condBlockRetAdd
missNullCheckN",-              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {,"+              JSDocInfo rValueInfo = rValue.getJSDocInfo();
+              if (rValueInfo != null && rValueInfo.hasType()) {
+                return rValueInfo.getType().evaluate(scope, typeRegistry);
+              } else if (rValue.getJSType() != null
+                  && !rValue.getJSType().isUnknownType()) {","-              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {
+              JSDocInfo rValueInfo = rValue.getJSDocInfo();
+              if (rValueInfo != null && rValueInfo.hasType()) {
+                return rValueInfo.getType().evaluate(scope, typeRegistry);
+              } else if (rValue.getJSType() != null
+                  && !rValue.getJSType().isUnknownType()) {"
Closure 13,junit.framework.AssertionFailedError,"codeMove
singleLine",-        traverse(c);,+        traverse(c);,"-        traverse(c);
+        traverse(c);"
Closure 21,junit.framework.AssertionFailedError,"condBlockRem
expLogicExpand
expLogicMod
wrongComp","-    if (n.isExprResult()) {
-    if (parent.getType() == Token.COMMA) {
-      if (isResultUsed) {
-        return;
-      }
-      if (n == parent.getLastChild()) {
-        for (Node an : parent.getAncestors()) {
-          int ancestorType = an.getType();
-          if (ancestorType == Token.COMMA) continue;
-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;
-          else break;
-        }
-      }
-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
-      if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {
-        return;
-      }
-    }
-    if (","+    if (n.isExprResult() || n.isBlock()) {
+    if (!isResultUsed &&","-    if (n.isExprResult()) {
+    if (n.isExprResult() || n.isBlock()) {
-    if (parent.getType() == Token.COMMA) {
-      if (isResultUsed) {
-        return;
-      }
-      if (n == parent.getLastChild()) {
-        for (Node an : parent.getAncestors()) {
-          int ancestorType = an.getType();
-          if (ancestorType == Token.COMMA) continue;
-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;
-          else break;
-        }
-      }
-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
-      if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {
-        return;
-      }
-    }
-    if (
+    if (!isResultUsed &&"
Closure 15,junit.framework.AssertionFailedError,condBlockRetAdd,,"+        if (n.isDelProp()) {
+          return true;
+        }","+        if (n.isDelProp()) {
+          return true;
+        }"
Closure 16,junit.framework.AssertionFailedError,"initFix
wrapsMethod
wrongComp","-    AliasedTypeNode(Node typeReference,
-      typeReference.setString(aliasName);
-          aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex)));","+    private final Node aliasDefinition;
+    AliasedTypeNode(Node typeReference, Node aliasDefinition,
+      this.aliasDefinition = aliasDefinition;
+      String typeName = typeReference.getString();
+      String aliasExpanded =
+          Preconditions.checkNotNull(aliasDefinition.getQualifiedName());
+      Preconditions.checkState(typeName.startsWith(aliasName));
+      typeReference.setString(typeName.replaceFirst(aliasName, aliasExpanded));
+          aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode, baseName));","+    private final Node aliasDefinition;
-    AliasedTypeNode(Node typeReference,
+    AliasedTypeNode(Node typeReference, Node aliasDefinition,
+      this.aliasDefinition = aliasDefinition;
-      typeReference.setString(aliasName);
+      String typeName = typeReference.getString();
+      String aliasExpanded =
+          Preconditions.checkNotNull(aliasDefinition.getQualifiedName());
+      Preconditions.checkState(typeName.startsWith(aliasName));
+      typeReference.setString(typeName.replaceFirst(aliasName, aliasExpanded));
-          aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex)));
+          aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode, baseName));"
Closure 18,junit.framework.AssertionFailedError,"expLogicReduce
singleLine",-      if (options.dependencyOptions.needsManagement() && options.closurePass) {,+      if (options.dependencyOptions.needsManagement()) {,"-      if (options.dependencyOptions.needsManagement() && options.closurePass) {
+      if (options.dependencyOptions.needsManagement()) {"
Closure 20,junit.framework.AssertionFailedError,"expLogicExpand
missNullCheckP
singleLine",-      if (value != null) {,"+      if (value != null && value.getNext() == null &&
+          NodeUtil.isImmutableValue(value)) {","-      if (value != null) {
+      if (value != null && value.getNext() == null &&
+          NodeUtil.isImmutableValue(value)) {"
Closure 19,java.lang.IllegalArgumentException,condBlockOthersAdd,,"+      case Token.THIS:
+        break;","+      case Token.THIS:
+        break;"
Closure 23,junit.framework.AssertionFailedError,"expLogicReduce
wrapsIfElse",-    for (int i = 0; current != null && i < intIndex; i++) {,"+    for (int i = 0; current != null; i++) {
+      if (i != intIndex) {
+        if (mayHaveSideEffects(current)) {
+          return n;
+        }
+      } else {
+      }","-    for (int i = 0; current != null && i < intIndex; i++) {
+    for (int i = 0; current != null; i++) {
+      if (i != intIndex) {
+        if (mayHaveSideEffects(current)) {
+          return n;
+        }
+      } else {
+      }"
Closure 24,junit.framework.AssertionFailedError,"condBlockOthersAdd
expLogicExpand
missComp","-        if (parent.isVar()) {
-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {
-        }","+        if (parent.isVar() &&
+            n.hasChildren() && n.getFirstChild().isQualifiedName()) {
+        } else if (v.isBleedingFunction()) {
+        } else if (parent.getType() == Token.LP) {","-        if (parent.isVar()) {
-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {
+        if (parent.isVar() &&
+            n.hasChildren() && n.getFirstChild().isQualifiedName()) {
+        } else if (v.isBleedingFunction()) {
+        } else if (parent.getType() == Token.LP) {
-        }"
Closure 22,junit.framework.AssertionFailedError,"condBlockRem
expLogicMod
missNullCheckN
unwrapIfElse
wrongComp","-    if (parent.getType() == Token.COMMA) {
-      Node gramps = parent.getParent();
-      if (gramps.isCall() && parent == gramps.getFirstChild()) {
-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && ""eval"".equals(n.getNext().getString())) {
-        }
-      if (n == parent.getLastChild()) {
-        for (Node an : parent.getAncestors()) {
-          int ancestorType = an.getType();
-          if (ancestorType == Token.COMMA)
-            continue;
-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)
-            return;
-          else
-            break;
-        }
-      }
-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||
-           n == parent.getFirstChild().getNext().getNext())) {
-      } else {
-      }
-      if (n.isQualifiedName() && n.getJSDocInfo() != null) {
-        return;
-      } else if (n.isExprResult()) {
-        return;
-      }","+    if (n.isExprResult() || n.isBlock()) {
+    if (n.isQualifiedName() && n.getJSDocInfo() != null) {","-    if (parent.getType() == Token.COMMA) {
-      Node gramps = parent.getParent();
-      if (gramps.isCall() && parent == gramps.getFirstChild()) {
-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && ""eval"".equals(n.getNext().getString())) {
+    if (n.isExprResult() || n.isBlock()) {
-        }
-      if (n == parent.getLastChild()) {
-        for (Node an : parent.getAncestors()) {
-          int ancestorType = an.getType();
-          if (ancestorType == Token.COMMA)
-            continue;
-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)
-            return;
-          else
-            break;
-        }
-      }
-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||
-           n == parent.getFirstChild().getNext().getNext())) {
-      } else {
+    if (n.isQualifiedName() && n.getJSDocInfo() != null) {
-      }
-      if (n.isQualifiedName() && n.getJSDocInfo() != null) {
-        return;
-      } else if (n.isExprResult()) {
-        return;
-      }"
Closure 26,junit.framework.AssertionFailedError,"condBlockRetAdd
missComp",,"+    private Set<String> modulesWithExports = Sets.newHashSet();
+      if (!modulesWithExports.contains(moduleName)) {
+        return;
+      }
+      modulesWithExports.add(moduleName);","+    private Set<String> modulesWithExports = Sets.newHashSet();
+      if (!modulesWithExports.contains(moduleName)) {
+        return;
+      }
+      modulesWithExports.add(moduleName);"
Closure 25,junit.framework.ComparisonFailure,"blockRemove
notClassified","-    scope = traverse(constructor, scope);
-    for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {
-      scope = traverse(arg, scope);
-    }","+    scope = traverseChildren(n, scope);
+          backwardsInferenceFromCallSite(n, ct);","+    scope = traverseChildren(n, scope);
-    scope = traverse(constructor, scope);
+          backwardsInferenceFromCallSite(n, ct);
-    for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {
-      scope = traverse(arg, scope);
-    }"
Closure 27,java.lang.IllegalStateException,"copyPaste
wrongComp
wrongMethodRef","-    Preconditions.checkState(tryBody.isLabelName());
-    Preconditions.checkState(finallyBody.isLabelName());
-    Node catchBody = block(catchNode).copyInformationFrom(catchNode);","+  private static Node blockUnchecked(Node stmt) {
+    return new Node(Token.BLOCK, stmt);
+  }
+    Preconditions.checkState(tryBody.isBlock());
+    Preconditions.checkState(finallyBody.isBlock());
+    Node catchBody = blockUnchecked(catchNode).copyInformationFrom(catchNode);","+  private static Node blockUnchecked(Node stmt) {
+    return new Node(Token.BLOCK, stmt);
+  }
-    Preconditions.checkState(tryBody.isLabelName());
-    Preconditions.checkState(finallyBody.isLabelName());
+    Preconditions.checkState(tryBody.isBlock());
+    Preconditions.checkState(finallyBody.isBlock());
-    Node catchBody = block(catchNode).copyInformationFrom(catchNode);
+    Node catchBody = blockUnchecked(catchNode).copyInformationFrom(catchNode);"
Closure 29,junit.framework.AssertionFailedError,"condBlockOthersAdd
condBlockRetAdd
missComp",,"+      Set<String> validProperties = Sets.newHashSet();
+          String propName = parent.getLastChild().getString();
+          if (!validProperties.contains(propName)) {
+            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {
+              validProperties.add(propName);
+            } else {
+              return false;
+            }
+          }
+          validProperties.add(child.getString());","+      Set<String> validProperties = Sets.newHashSet();
+          String propName = parent.getLastChild().getString();
+          if (!validProperties.contains(propName)) {
+            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {
+              validProperties.add(propName);
+            } else {
+              return false;
+            }
+          }
+          validProperties.add(child.getString());"
Closure 30,junit.framework.AssertionFailedError,"condBlockRetAdd
expLogicReduce
initFix
missNullCheckP
wrapsIfElse
wrongMethodRef","-    (new NodeTraversal(compiler, this)).traverse(root);
-        if (n.isName() && jsScope.isDeclared(n.getString(), true)) {","+    (new NodeTraversal(compiler, this)).traverseRoots(externs, root);
+    private boolean unknownDependencies = false;
+        if (n.isName()) {
+          if (dep == null) {
+            def.unknownDependencies = true;
+          } else {
+          }
+    if (def.unknownDependencies) {
+      return true;
+    }","-    (new NodeTraversal(compiler, this)).traverse(root);
+    (new NodeTraversal(compiler, this)).traverseRoots(externs, root);
+    private boolean unknownDependencies = false;
-        if (n.isName() && jsScope.isDeclared(n.getString(), true)) {
+        if (n.isName()) {
+          if (dep == null) {
+            def.unknownDependencies = true;
+          } else {
+          }
+    if (def.unknownDependencies) {
+      return true;
+    }"
Closure 31,junit.framework.AssertionFailedError,"expLogicReduce
singleLine",-          !options.skipAllPasses &&,,-          !options.skipAllPasses &&
Closure 32,junit.framework.ComparisonFailure,"condBlockOthersAdd
condBlockRem
missComp","-          if (builder.length() > 0) {
-            builder.append(' ');
-          }","+    int lineStartChar = -1;
+            lineStartChar = stream.getCharno() + 1;
+          lineStartChar = 0;
+          boolean isEOC = token == JsDocToken.EOC;
+          if (!isEOC) {
+            if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE) {
+              int numSpaces = stream.getCharno() - lineStartChar;
+              for (int i = 0; i < numSpaces; i++) {
+                builder.append(' ');
+              }
+              lineStartChar = -1;
+            } else if (builder.length() > 0) {
+              builder.append(' ');
+            }
+          }","+    int lineStartChar = -1;
+            lineStartChar = stream.getCharno() + 1;
+          lineStartChar = 0;
+          boolean isEOC = token == JsDocToken.EOC;
+          if (!isEOC) {
+            if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE) {
+              int numSpaces = stream.getCharno() - lineStartChar;
+              for (int i = 0; i < numSpaces; i++) {
+                builder.append(' ');
+              }
+              lineStartChar = -1;
+            } else if (builder.length() > 0) {
+              builder.append(' ');
+            }
+          }
-          if (builder.length() > 0) {
-            builder.append(' ');
-          }"
Closure 33,junit.framework.AssertionFailedError,condBlockRetAdd,,"+    if (hasReferenceName()) {
+      return;
+    }","+    if (hasReferenceName()) {
+      return;
+    }"
Closure 28,junit.framework.AssertionFailedError,"notClassified
wrongComp",,"+    @Override
+    void addConstant(String newcode) {
+      add(""0"");
+    }","+    @Override
+    void addConstant(String newcode) {
+      add(""0"");
+    }"
Closure 34,java.lang.StackOverflowError,"expLogicExpand
wrongMethodRef
wrongVarRef","-        addExpr(first, p, context);
-        cc.addOp(opstr, true);
-        addExpr(last, p + 1, rhsContext);
-      cc.listSeparator();
-        if (getLastChar() != ' ') {","+        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);
+      cc.addOp(opStr, true);
+        if (getLastChar() != ' ' && op.charAt(0) != ',') {","-        addExpr(first, p, context);
-        cc.addOp(opstr, true);
-        addExpr(last, p + 1, rhsContext);
+        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);
-      cc.listSeparator();
+      cc.addOp(opStr, true);
-        if (getLastChar() != ' ') {
+        if (getLastChar() != ' ' && op.charAt(0) != ',') {"
Closure 35,junit.framework.AssertionFailedError,"condBlockRem
expLogicReduce","-    if (constraintObj != null && constraintObj.isRecordType()) {
-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());
-      if (objType != null) {
-        for (String prop : constraintObj.getOwnPropertyNames()) {
-          JSType propType = constraintObj.getPropertyType(prop);
-          if (!objType.isPropertyTypeDeclared(prop)) {
-            JSType typeToInfer = propType;
-            if (!objType.hasProperty(prop)) {
-              typeToInfer =
-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);
-            }
-            objType.defineInferredProperty(prop, typeToInfer, null);
-          }
-        }
-      }","+    if (constraintObj != null) {
+      type.matchConstraint(constraintObj);","-    if (constraintObj != null && constraintObj.isRecordType()) {
-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());
-      if (objType != null) {
-        for (String prop : constraintObj.getOwnPropertyNames()) {
-          JSType propType = constraintObj.getPropertyType(prop);
-          if (!objType.isPropertyTypeDeclared(prop)) {
-            JSType typeToInfer = propType;
-            if (!objType.hasProperty(prop)) {
-              typeToInfer =
-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);
-            }
-            objType.defineInferredProperty(prop, typeToInfer, null);
-          }
-        }
-      }
+    if (constraintObj != null) {
+      type.matchConstraint(constraintObj);"
Closure 37,java.lang.RuntimeException,"condBlockOthersAdd
wrongMethodRef",-            body.isBlock());,"+            body.isBlock(), body);
+      if (!bodyNode.isBlock()) {
+        Preconditions.checkState(config.isIdeMode);
+        bodyNode = IR.block();
+      }","-            body.isBlock());
+            body.isBlock(), body);
+      if (!bodyNode.isBlock()) {
+        Preconditions.checkState(config.isIdeMode);
+        bodyNode = IR.block();
+      }"
Closure 36,junit.framework.AssertionFailedError,"condBlockRetAdd
missNullCheckN",,"+          if (convention.getSingletonGetterClassName(callNode) != null) {
+            return false;
+          }","+          if (convention.getSingletonGetterClassName(callNode) != null) {
+            return false;
+          }"
Closure 39,junit.framework.ComparisonFailure,"expLogicExpand
wrapsIfElse
wrongMethodRef","-        sb.append(getPropertyType(property).toString());
-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {
-      return ""{...}"";","+        sb.append(getPropertyType(property).toStringHelper(forAnnotations));
+        if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) {
+      return forAnnotations ? ""?"" : ""{...}"";","-        sb.append(getPropertyType(property).toString());
+        sb.append(getPropertyType(property).toStringHelper(forAnnotations));
-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {
+        if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) {
-      return ""{...}"";
+      return forAnnotations ? ""?"" : ""{...}"";"
Closure 45,junit.framework.AssertionFailedError,"condBlockOthersAdd
expLogicExpand
initFix
wrongMethodRef","-          if (assignedToUnknownValue && hasPropertyAssign) {
-      this.maybeAliased = !assignNode.getParent().isExprResult();","+          boolean maybeEscaped = false;
+            if (assign.maybeAliased) {
+              maybeEscaped = true;
+            }
+          if ((assignedToUnknownValue || maybeEscaped) && hasPropertyAssign) {
+      this.maybeAliased = NodeUtil.isExpressionResultUsed(assignNode);","+          boolean maybeEscaped = false;
+            if (assign.maybeAliased) {
+              maybeEscaped = true;
+            }
-          if (assignedToUnknownValue && hasPropertyAssign) {
+          if ((assignedToUnknownValue || maybeEscaped) && hasPropertyAssign) {
-      this.maybeAliased = !assignNode.getParent().isExprResult();
+      this.maybeAliased = NodeUtil.isExpressionResultUsed(assignNode);"
Closure 38,junit.framework.ComparisonFailure,"expLogicExpand
singleLine",-    if (x < 0 && prev == '-') {,+    if ((x < 0 || negativeZero) && prev == '-') {,"-    if (x < 0 && prev == '-') {
+    if ((x < 0 || negativeZero) && prev == '-') {"
Closure 40,java.lang.RuntimeException,"constChange
unwrapIfElse","-          JsName name = getName(ns.name, false);
-          if (name != null) {
-          }","+          JsName name = getName(ns.name, true);","-          JsName name = getName(ns.name, false);
-          if (name != null) {
+          JsName name = getName(ns.name, true);
-          }"
Closure 42,junit.framework.AssertionFailedError,"condBlockRetAdd
missComp",,"+      if (loopNode.isForEach()) {
+        errorReporter.error(
+            ""unsupported language extension: for each"",
+            sourceName,
+            loopNode.getLineno(), """", 0);
+        return newNode(Token.EXPR_RESULT, Node.newNumber(0));
+      }","+      if (loopNode.isForEach()) {
+        errorReporter.error(
+            ""unsupported language extension: for each"",
+            sourceName,
+            loopNode.getLineno(), """", 0);
+        return newNode(Token.EXPR_RESULT, Node.newNumber(0));
+      }"
Closure 41,junit.framework.AssertionFailedError,"condBlockOthersAdd
missComp
missNullCheckN",,"+      while (oldParams.hasNext()) {
+        paramBuilder.newParameterFromNode(oldParams.next());
+      }
+    if (!isVarArgs) {
+      while (oldParameterType != null && !isVarArgs) {
+        builder.newParameterFromNode(oldParameterType);
+        oldParameterType = oldParameterType.getNext();
+      }
+    }","+      while (oldParams.hasNext()) {
+        paramBuilder.newParameterFromNode(oldParams.next());
+      }
+    if (!isVarArgs) {
+      while (oldParameterType != null && !isVarArgs) {
+        builder.newParameterFromNode(oldParameterType);
+        oldParameterType = oldParameterType.getNext();
+      }
+    }"
Closure 44,junit.framework.ComparisonFailure,condBlockOthersAdd,,"+    } else if (c == '/' && getLastChar() == '/') {
+      append("" "");","+    } else if (c == '/' && getLastChar() == '/') {
+      append("" "");"
Closure 43,junit.framework.ComparisonFailure,"condBlockOthersAdd
missComp
missNullCheckN
missNullCheckP
wrapsIfElse",,"+    private List<Node> lentObjectLiterals = null;
+      if (n.getParent() != null && NodeUtil.isStatement(n) &&
+          lentObjectLiterals != null) {
+        for (Node objLit : lentObjectLiterals) {
+          defineObjectLiteral(objLit);
+        }
+        lentObjectLiterals.clear();
+      }
+          JSDocInfo info = n.getJSDocInfo();
+          if (info != null &&
+              info.getLendsName() != null) {
+            if (lentObjectLiterals == null) {
+              lentObjectLiterals = Lists.newArrayList();
+            }
+            lentObjectLiterals.add(n);
+          } else {
+          }","+    private List<Node> lentObjectLiterals = null;
+      if (n.getParent() != null && NodeUtil.isStatement(n) &&
+          lentObjectLiterals != null) {
+        for (Node objLit : lentObjectLiterals) {
+          defineObjectLiteral(objLit);
+        }
+        lentObjectLiterals.clear();
+      }
+          JSDocInfo info = n.getJSDocInfo();
+          if (info != null &&
+              info.getLendsName() != null) {
+            if (lentObjectLiterals == null) {
+              lentObjectLiterals = Lists.newArrayList();
+            }
+            lentObjectLiterals.add(n);
+          } else {
+          }"
Closure 46,junit.framework.AssertionFailedError,"blockRemove
condBlockRem
wrongComp","-  @Override
-  public JSType getLeastSupertype(JSType that) {
-    if (!that.isRecordType()) {
-      return super.getLeastSupertype(that);
-    }
-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);
-    for (String property : properties.keySet()) {
-      if (that.toMaybeRecordType().hasProperty(property) &&
-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(
-              getPropertyType(property))) {
-        builder.addProperty(property, getPropertyType(property),
-            getPropertyNode(property));
-      }
-    }
-    return builder.build();
-  }",,"-  @Override
-  public JSType getLeastSupertype(JSType that) {
-    if (!that.isRecordType()) {
-      return super.getLeastSupertype(that);
-    }
-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);
-    for (String property : properties.keySet()) {
-      if (that.toMaybeRecordType().hasProperty(property) &&
-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(
-              getPropertyType(property))) {
-        builder.addProperty(property, getPropertyType(property),
-            getPropertyNode(property));
-      }
-    }
-    return builder.build();
-  }"
Closure 47,junit.framework.AssertionFailedError,"condBlockOthersAdd
initFix","-        .setLineNumber(entry.getSourceLine())
-        .setColumnPosition(entry.getSourceColumn());
-        new FilePosition(node.getLineno(), node.getCharno()),","+        .setLineNumber(entry.getSourceLine() + 1)
+        .setColumnPosition(entry.getSourceColumn() + 1);
+    int lineBaseOffset = 1;
+    if (generator instanceof SourceMapGeneratorV1
+        || generator instanceof SourceMapGeneratorV2) {
+      lineBaseOffset = 0;
+    }
+        new FilePosition(node.getLineno() - lineBaseOffset, node.getCharno()),","-        .setLineNumber(entry.getSourceLine())
-        .setColumnPosition(entry.getSourceColumn());
+        .setLineNumber(entry.getSourceLine() + 1)
+        .setColumnPosition(entry.getSourceColumn() + 1);
+    int lineBaseOffset = 1;
+    if (generator instanceof SourceMapGeneratorV1
+        || generator instanceof SourceMapGeneratorV2) {
+      lineBaseOffset = 0;
+    }
-        new FilePosition(node.getLineno(), node.getCharno()),
+        new FilePosition(node.getLineno() - lineBaseOffset, node.getCharno()),"
Closure 48,junit.framework.AssertionFailedError,"condBlockOthersAdd
expLogicExpand","-      if (inferred) {
-        inferred = !(rhsValue != null &&
-            rhsValue.isFunction() &&
-            (info != null || !scope.isDeclared(qName, false)));","+      if (inferred && rhsValue != null && rhsValue.isFunction()) {
+        if (info != null) {
+          inferred = false;
+        } else if (!scope.isDeclared(qName, false) &&
+                   n.isUnscopedQualifiedName()) {
+          inferred = false;
+        }","-      if (inferred) {
+      if (inferred && rhsValue != null && rhsValue.isFunction()) {
-        inferred = !(rhsValue != null &&
-            rhsValue.isFunction() &&
-            (info != null || !scope.isDeclared(qName, false)));
+        if (info != null) {
+          inferred = false;
+        } else if (!scope.isDeclared(qName, false) &&
+                   n.isUnscopedQualifiedName()) {
+          inferred = false;
+        }"
Closure 49,junit.framework.AssertionFailedError,"blockRemove
condBlockOthersAdd
condBlockRem
missComp","-    if (declarationRoot.getType() == Token.FUNCTION) {
-      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {
-        String name = c.getString();
-        renamer.addDeclaredName(name);
-      }
-      Node functionBody = declarationRoot.getLastChild();
-      findDeclaredNames(functionBody, null, renamer);
-    }  else ","+          nameStack.push(renamer);
+        }
+        break;
+      case Token.LP: {
+          Renamer renamer = nameStack.peek().forChildScope();
+          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
+            String name = c.getString();
+            renamer.addDeclaredName(name);
+          }
+          Node functionBody = n.getNext();
+          findDeclaredNames(functionBody, null, renamer);
+        nameStack.pop();
+      case Token.LP:
+        break;","-    if (declarationRoot.getType() == Token.FUNCTION) {
-      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {
-        String name = c.getString();
-        renamer.addDeclaredName(name);
-      }
-      Node functionBody = declarationRoot.getLastChild();
-      findDeclaredNames(functionBody, null, renamer);
-    }  else 
+          nameStack.push(renamer);
+        }
+        break;
+      case Token.LP: {
+          Renamer renamer = nameStack.peek().forChildScope();
+          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
+            String name = c.getString();
+            renamer.addDeclaredName(name);
+          }
+          Node functionBody = n.getNext();
+          findDeclaredNames(functionBody, null, renamer);
+        nameStack.pop();
+      case Token.LP:
+        break;"
Closure 50,junit.framework.AssertionFailedError,"condBlockOthersAdd
expLogicExpand
missNullCheckN",-      if (!NodeUtil.isImmutableValue(right)) {,"+      if (right.getNext() != null || !NodeUtil.isImmutableValue(right)) {
+    if (right != null && right.getType() == Token.STRING
+        && "","".equals(right.getString())) {
+      n.removeChild(right);
+      reportCodeChange();
+    }","-      if (!NodeUtil.isImmutableValue(right)) {
+      if (right.getNext() != null || !NodeUtil.isImmutableValue(right)) {
+    if (right != null && right.getType() == Token.STRING
+        && "","".equals(right.getString())) {
+      n.removeChild(right);
+      reportCodeChange();
+    }"
Closure 53,java.lang.RuntimeException,wrapsIfElse,,"+      if (nodes.isEmpty()) {
+        replacement = new Node(Token.TRUE);
+      } else {
+      }","+      if (nodes.isEmpty()) {
+        replacement = new Node(Token.TRUE);
+      } else {
+      }"
Closure 51,junit.framework.ComparisonFailure,"expLogicExpand
singleLine",-    if ((long) x == x) {,+    if ((long) x == x && !isNegativeZero(x)) {,"-    if ((long) x == x) {
+    if ((long) x == x && !isNegativeZero(x)) {"
Closure 52,junit.framework.ComparisonFailure,"expLogicExpand
singleLine",-    return len > 0;,+    return len > 0 && s.charAt(0) != '0';,"-    return len > 0;
+    return len > 0 && s.charAt(0) != '0';"
Closure 59,junit.framework.AssertionFailedError,"expLogicExpand
singleLine",-    if (options.checkGlobalThisLevel.isOn()) {,"+    if (options.checkGlobalThisLevel.isOn() &&
+        !options.disables(DiagnosticGroups.GLOBAL_THIS)) {","-    if (options.checkGlobalThisLevel.isOn()) {
+    if (options.checkGlobalThisLevel.isOn() &&
+        !options.disables(DiagnosticGroups.GLOBAL_THIS)) {"
Closure 55,java.lang.IllegalStateException,"expLogicExpand
singleLine",-    return NodeUtil.isFunctionExpression(n);,"+    return NodeUtil.isFunctionExpression(n)
+        && !NodeUtil.isGetOrSetKey(n.getParent());","-    return NodeUtil.isFunctionExpression(n);
+    return NodeUtil.isFunctionExpression(n)
+        && !NodeUtil.isGetOrSetKey(n.getParent());"
Closure 54,junit.framework.ComparisonFailure,"condBlockOthersAdd
expLogicReduce
missComp
missNullCheckN
wrapsIfElse
wrongVarRef","-          if (!qVar.isTypeInferred()) {
-        baseType.isUnknownType() ||
-    boolean replacedPrototype = prototype != null;","+          ObjectType qVarType = ObjectType.cast(qVar.getType());
+          if (qVarType != null &&
+              rhsValue != null &&
+              rhsValue.getType() == Token.OBJECTLIT) {
+            typeRegistry.resetImplicitPrototype(
+                rhsValue.getJSType(), qVarType.getImplicitPrototype());
+          } else if (!qVar.isTypeInferred()) {
+    PrototypeObjectType oldPrototype = this.prototype;
+    boolean replacedPrototype = oldPrototype != null;
+    if (oldPrototype != null) {
+      oldPrototype.setOwnerFunction(null);
+    }","-          if (!qVar.isTypeInferred()) {
+          ObjectType qVarType = ObjectType.cast(qVar.getType());
+          if (qVarType != null &&
+              rhsValue != null &&
+              rhsValue.getType() == Token.OBJECTLIT) {
+            typeRegistry.resetImplicitPrototype(
+                rhsValue.getJSType(), qVarType.getImplicitPrototype());
+          } else if (!qVar.isTypeInferred()) {
-        baseType.isUnknownType() ||
-    boolean replacedPrototype = prototype != null;
+    PrototypeObjectType oldPrototype = this.prototype;
+    boolean replacedPrototype = oldPrototype != null;
+    if (oldPrototype != null) {
+      oldPrototype.setOwnerFunction(null);
+    }"
Closure 56,junit.framework.ComparisonFailure,wrapsIfElse,,"+      if (pos >= js.length()) {
+      } else {
+        return js.substring(pos, js.length());
+      }","+      if (pos >= js.length()) {
+      } else {
+        return js.substring(pos, js.length());
+      }"
Closure 58,java.lang.IllegalStateException,wrapsIfElse,,"+          if (NodeUtil.isName(lhs)) {
+          } else {
+            computeGenKill(lhs, gen, kill, conditional);
+          }","+          if (NodeUtil.isName(lhs)) {
+          } else {
+            computeGenKill(lhs, gen, kill, conditional);
+          }"
Closure 57,junit.framework.AssertionFailedError,"expLogicExpand
singleLine",-          if (target != null) {,+          if (target != null && target.getType() == Token.STRING) {,"-          if (target != null) {
+          if (target != null && target.getType() == Token.STRING) {"
Closure 62,junit.framework.ComparisonFailure,"expLogicMod
singleLine",-          && 0 <= charno && charno < sourceExcerpt.length()) {,+          && 0 <= charno && charno <= sourceExcerpt.length()) {,"-          && 0 <= charno && charno < sourceExcerpt.length()) {
+          && 0 <= charno && charno <= sourceExcerpt.length()) {"
Closure 60,junit.framework.AssertionFailedError,"condBlockRetAdd
wrapsIf",,"+      case Token.VOID:
+        return TernaryValue.FALSE;
+        if (!mayHaveSideEffects(n.getFirstChild())) {
+        }
+        break;","+      case Token.VOID:
+        return TernaryValue.FALSE;
+        if (!mayHaveSideEffects(n.getFirstChild())) {
+        }
+        break;"
Closure 63,junit.framework.ComparisonFailure,"expLogicMod
singleLine",-          && 0 <= charno && charno < sourceExcerpt.length()) {,+          && 0 <= charno && charno <= sourceExcerpt.length()) {,"-          && 0 <= charno && charno < sourceExcerpt.length()) {
+          && 0 <= charno && charno <= sourceExcerpt.length()) {"
Closure 61,junit.framework.AssertionFailedError,"condBlockOthersAdd
condBlockRetAdd",,"+      if (nameNode.getFirstChild().getType() == Token.NAME) {
+        String namespaceName = nameNode.getFirstChild().getString();
+        if (namespaceName.equals(""Math"")) {
+          return false;
+        }
+      }","+      if (nameNode.getFirstChild().getType() == Token.NAME) {
+        String namespaceName = nameNode.getFirstChild().getString();
+        if (namespaceName.equals(""Math"")) {
+          return false;
+        }
+      }"
Closure 64,junit.framework.AssertionFailedError,expLogicExpand,"-        String code = toSource(root, sourceMap);
-    return toSource(n, null);
-  private String toSource(Node n, SourceMap sourceMap) {
-    builder.setTagAsStrict(","+        String code = toSource(root, sourceMap, inputSeqNum == 0);
+    return toSource(n, null, true);
+  private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) {
+    builder.setTagAsStrict(firstOutput &&","-        String code = toSource(root, sourceMap);
+        String code = toSource(root, sourceMap, inputSeqNum == 0);
-    return toSource(n, null);
+    return toSource(n, null, true);
-  private String toSource(Node n, SourceMap sourceMap) {
+  private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) {
-    builder.setTagAsStrict(
+    builder.setTagAsStrict(firstOutput &&"
Closure 65,junit.framework.ComparisonFailure,"constChange
singleLine","-        case '\0': sb.append(""\\0""); break;","+        case '\0': sb.append(""\\000""); break;","-        case '\0': sb.append(""\\0""); break;
+        case '\0': sb.append(""\\000""); break;"
Closure 66,junit.framework.AssertionFailedError,condBlockOthersAdd,,"+        } else {
+          typeable = false;","+        } else {
+          typeable = false;"
Closure 73,junit.framework.ComparisonFailure,"expLogicMod
singleLine",-            if (c > 0x1f && c <= 0x7f) {,+            if (c > 0x1f && c < 0x7f) {,"-            if (c > 0x1f && c <= 0x7f) {
+            if (c > 0x1f && c < 0x7f) {"
Closure 67,junit.framework.AssertionFailedError,"expLogicExpand
singleLine",-          ) {,+          && assign.getParent().getType() == Token.EXPR_RESULT) {,"-          ) {
+          && assign.getParent().getType() == Token.EXPR_RESULT) {"
Closure 74,junit.framework.AssertionFailedError,"condBlockRetAdd
copyPaste
missComp
wrongMethodRef","-    int lhType = left.getType();
-    int rhType = right.getType();","+    int lhType = getNormalizedNodeType(left);
+    int rhType = getNormalizedNodeType(right);
+  private int getNormalizedNodeType(Node n) {
+    int type = n.getType();
+    if (type == Token.NOT) {
+      TernaryValue value = NodeUtil.getPureBooleanValue(n);
+      switch (value) {
+        case TRUE:
+          return Token.TRUE;
+        case FALSE:
+          return Token.FALSE;
+      }
+    }
+    return type;
+  }","-    int lhType = left.getType();
-    int rhType = right.getType();
+    int lhType = getNormalizedNodeType(left);
+    int rhType = getNormalizedNodeType(right);
+  private int getNormalizedNodeType(Node n) {
+    int type = n.getType();
+    if (type == Token.NOT) {
+      TernaryValue value = NodeUtil.getPureBooleanValue(n);
+      switch (value) {
+        case TRUE:
+          return Token.TRUE;
+        case FALSE:
+          return Token.FALSE;
+      }
+    }
+    return type;
+  }"
Closure 71,junit.framework.AssertionFailedError,"expLogicMod
missNullCheckN
singleLine",-      boolean isOverride = t.inGlobalScope() &&,+      boolean isOverride = parent.getJSDocInfo() != null &&,"-      boolean isOverride = t.inGlobalScope() &&
+      boolean isOverride = parent.getJSDocInfo() != null &&"
Closure 68,junit.framework.AssertionFailedError,"codeMove
copyPaste
missComp
unwrapIfElse",-                  },"+                  }
+    restoreLookAhead(token);
+      restoreLookAhead(token);","+                  }
-                  }
+    restoreLookAhead(token);
+      restoreLookAhead(token);"
Closure 69,junit.framework.AssertionFailedError,"condBlockOthersAdd
missComp",,"+      if (functionType.isOrdinaryFunction() &&
+          !functionType.getTypeOfThis().isUnknownType() &&
+          !functionType.getTypeOfThis().isNativeObjectType() &&
+          !(child.getType() == Token.GETELEM ||
+            child.getType() == Token.GETPROP)) {
+        report(t, n, EXPECTED_THIS_TYPE, functionType.toString());
+      }","+      if (functionType.isOrdinaryFunction() &&
+          !functionType.getTypeOfThis().isUnknownType() &&
+          !functionType.getTypeOfThis().isNativeObjectType() &&
+          !(child.getType() == Token.GETELEM ||
+            child.getType() == Token.GETPROP)) {
+        report(t, n, EXPECTED_THIS_TYPE, functionType.toString());
+      }"
Closure 70,junit.framework.AssertionFailedError,"constChange
singleLine","-                  jsDocParameter.getJSType(), true);","+                  jsDocParameter.getJSType(), false);","-                  jsDocParameter.getJSType(), true);
+                  jsDocParameter.getJSType(), false);"
Closure 72,junit.framework.AssertionFailedError,"expLogicExpand
missComp",-      if (li.referenced) {,"+    new RenameLabels(compiler, new LabelNameSupplier(idSupplier), false)
+        .process(null, fnNode);
+      if (li.referenced || !removeUnused) {","+    new RenameLabels(compiler, new LabelNameSupplier(idSupplier), false)
+        .process(null, fnNode);
-      if (li.referenced) {
+      if (li.referenced || !removeUnused) {"
Closure 76,junit.framework.AssertionFailedError,"condBlockOthersAdd
condBlockRetAdd
missComp
missNullCheckN
unwrapIfElse","-            if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {
-            }
-          }
-      }
-          if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION
-      }","+          if (n.getNext() != null) {
+            state = isVariableReadBeforeKill(
+                n.getNext(), variable);
+            if (state == VariableLiveness.KILL) {
+              state = VariableLiveness.MAYBE_LIVE;
+            }
+          }
+          break;
+          if (n.getNext() != null && n.getNext().getNext() != null) {
+            state = checkHookBranchReadBeforeKill(
+                n.getNext(), n.getNext().getNext(), variable);
+          }
+          break;
+            if (state != VariableLiveness.MAYBE_LIVE) {
+              break;
+            }
+          }
+      }
+    if (ControlFlowGraph.isEnteringNewCfgNode(n)) { // Not a FUNCTION
+      return VariableLiveness.MAYBE_LIVE;
+    }
+        VariableLiveness v1 = isVariableReadBeforeKill(
+          n.getFirstChild(), variable);
+        VariableLiveness v2 = isVariableReadBeforeKill(
+          n.getLastChild(), variable);
+        if (v1 != VariableLiveness.MAYBE_LIVE) {
+          return v1;
+        } else if (v2 == VariableLiveness.READ) {
+          return VariableLiveness.READ;
+        } else {
+          return VariableLiveness.MAYBE_LIVE;
+        }
+        VariableLiveness first = isVariableReadBeforeKill(
+            n.getFirstChild(), variable);
+        if (first != VariableLiveness.MAYBE_LIVE) {
+          return first;
+        }","+          if (n.getNext() != null) {
+            state = isVariableReadBeforeKill(
+                n.getNext(), variable);
+            if (state == VariableLiveness.KILL) {
+              state = VariableLiveness.MAYBE_LIVE;
+            }
+          }
+          break;
+          if (n.getNext() != null && n.getNext().getNext() != null) {
+            state = checkHookBranchReadBeforeKill(
+                n.getNext(), n.getNext().getNext(), variable);
+          }
+          break;
-            if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {
+            if (state != VariableLiveness.MAYBE_LIVE) {
+              break;
+            }
+          }
+      }
-            }
-          }
-      }
+    if (ControlFlowGraph.isEnteringNewCfgNode(n)) { // Not a FUNCTION
+      return VariableLiveness.MAYBE_LIVE;
+    }
+        VariableLiveness v1 = isVariableReadBeforeKill(
+          n.getFirstChild(), variable);
+        VariableLiveness v2 = isVariableReadBeforeKill(
+          n.getLastChild(), variable);
+        if (v1 != VariableLiveness.MAYBE_LIVE) {
+          return v1;
+        } else if (v2 == VariableLiveness.READ) {
+          return VariableLiveness.READ;
+        } else {
+          return VariableLiveness.MAYBE_LIVE;
+        }
+        VariableLiveness first = isVariableReadBeforeKill(
+            n.getFirstChild(), variable);
+        if (first != VariableLiveness.MAYBE_LIVE) {
+          return first;
+        }
-          if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION
-      }"
Closure 79,java.lang.RuntimeException,"missComp
wrongMethodRef",-        .traverse(root);,"+        .traverseRoots(externs, root);
+    compiler.reportCodeChange();","-        .traverse(root);
+        .traverseRoots(externs, root);
+    compiler.reportCodeChange();"
Closure 77,junit.framework.ComparisonFailure,"condBlockOthersAdd
singleLine",,"+        case '\0': sb.append(""\\0""); break;","+        case '\0': sb.append(""\\0""); break;"
Closure 75,junit.framework.AssertionFailedError,"condBlockRetAdd
constChange
wrongVarRef",-        return TernaryValue.TRUE;,"+    if (rawJsString.contains(""\u000b"")) {
+      return null;
+    }
+        return TernaryValue.UNKNOWN;  // IE says ""no"", EcmaScript says ""yes""","+    if (rawJsString.contains(""\u000b"")) {
+      return null;
+    }
-        return TernaryValue.TRUE;
+        return TernaryValue.UNKNOWN;  // IE says ""no"", EcmaScript says ""yes"""
Closure 78,junit.framework.AssertionFailedError,copyPaste,"-          error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
-          error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);",,"-          error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
-          error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);"
Closure 83,junit.framework.AssertionFailedError,wrapsTryCatch,-        String param = params.getParameter(0);,"+        String param = null;
+        try {
+          param = params.getParameter(0);
+        } catch (CmdLineException e) {}","-        String param = params.getParameter(0);
+        String param = null;
+        try {
+          param = params.getParameter(0);
+        } catch (CmdLineException e) {}"
Closure 80,junit.framework.AssertionFailedError,expLogicExpand,,"+      case Token.DELPROP:
+      case Token.DELPROP:","+      case Token.DELPROP:
+      case Token.DELPROP:"
Closure 81,junit.framework.AssertionFailedError,condBlockOthersAdd,,"+        int functionType = functionNode.getFunctionType();
+        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {
+          errorReporter.error(
+            ""unnamed function statement"",
+            sourceName,
+            functionNode.getLineno(), """", 0);
+        }","+        int functionType = functionNode.getFunctionType();
+        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {
+          errorReporter.error(
+            ""unnamed function statement"",
+            sourceName,
+            functionNode.getLineno(), """", 0);
+        }"
Closure 82,junit.framework.AssertionFailedError,"expLogicExpand
singleLine",-    return isNoType() || isNoObjectType() || isNoResolvedType();,"+    return isNoType() || isNoObjectType() || isNoResolvedType() ||
+        (registry.getNativeFunctionType(
+             JSTypeNative.LEAST_FUNCTION_TYPE) == this);","-    return isNoType() || isNoObjectType() || isNoResolvedType();
+    return isNoType() || isNoObjectType() || isNoResolvedType() ||
+        (registry.getNativeFunctionType(
+             JSTypeNative.LEAST_FUNCTION_TYPE) == this);"
Closure 85,junit.framework.AssertionFailedError,"condBlockOthersAdd
condBlockRem
missNullCheckN
unwrapMethod","-    if (n.getParent() == null) {
-      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();
-      if (outEdges.size() == 1) {
-        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());
-      }
-    }
-      case Token.BLOCK:
-        if (n.hasChildren()) {
-          Node first = n.getFirstChild();
-          return tryRemoveUnconditionalBranching(first);
-        } else {
-          return tryRemoveUnconditionalBranching(ControlFlowAnalysis.computeFollowNode(n));
-        }
-          Node fallThrough = tryRemoveUnconditionalBranching(computeFollowing(n));","+          Node fallThrough = computeFollowing(n);
+    while (next != null && next.getType() == Token.BLOCK) {
+      if (next.hasChildren()) {
+        next = next.getFirstChild();
+      } else {
+        next = computeFollowing(next);
+      }
+    }","-    if (n.getParent() == null) {
-      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();
-      if (outEdges.size() == 1) {
-        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());
-      }
-    }
-      case Token.BLOCK:
-        if (n.hasChildren()) {
-          Node first = n.getFirstChild();
-          return tryRemoveUnconditionalBranching(first);
-        } else {
-          return tryRemoveUnconditionalBranching(ControlFlowAnalysis.computeFollowNode(n));
-        }
-          Node fallThrough = tryRemoveUnconditionalBranching(computeFollowing(n));
+          Node fallThrough = computeFollowing(n);
+    while (next != null && next.getType() == Token.BLOCK) {
+      if (next.hasChildren()) {
+        next = next.getFirstChild();
+      } else {
+        next = computeFollowing(next);
+      }
+    }"
Closure 86,junit.framework.AssertionFailedError,"constChange
expLogicMod
singleLine",-        return true;,+        return false;,"-        return true;
+        return false;"
Closure 84,junit.framework.AssertionFailedError,"condBlockOthersAdd
condBlockRetAdd
missComp",,"+      Node target = assign.getFirstChild();
+      if (!validAssignmentTarget(target)) {
+        errorReporter.error(
+          ""invalid assignment target"",
+          sourceName,
+          target.getLineno(), """", 0);
+      }
+        if (type == Token.INC || type == Token.DEC) {
+          if (!validAssignmentTarget(operand)) {
+            String msg = (type == Token.INC)
+                ? ""invalid increment target""
+                : ""invalid decrement target"";
+            errorReporter.error(
+              msg,
+              sourceName,
+              operand.getLineno(), """", 0);
+          }
+        }
+    private boolean validAssignmentTarget(Node target) {
+      switch (target.getType()) {
+        case Token.NAME:
+        case Token.GETPROP:
+        case Token.GETELEM:
+          return true;
+      }
+      return false;
+    }","+      Node target = assign.getFirstChild();
+      if (!validAssignmentTarget(target)) {
+        errorReporter.error(
+          ""invalid assignment target"",
+          sourceName,
+          target.getLineno(), """", 0);
+      }
+        if (type == Token.INC || type == Token.DEC) {
+          if (!validAssignmentTarget(operand)) {
+            String msg = (type == Token.INC)
+                ? ""invalid increment target""
+                : ""invalid decrement target"";
+            errorReporter.error(
+              msg,
+              sourceName,
+              operand.getLineno(), """", 0);
+          }
+        }
+    private boolean validAssignmentTarget(Node target) {
+      switch (target.getType()) {
+        case Token.NAME:
+        case Token.GETPROP:
+        case Token.GETELEM:
+          return true;
+      }
+      return false;
+    }"
Closure 89,junit.framework.AssertionFailedError,"condBlockOthersAdd
expLogicReduce
missNullCheckN",-      if (type != Type.FUNCTION && aliasingGets > 0) {,"+    if (rvalue != null && rvalue.getType() == Token.FUNCTION) {
+      checkForHosedThisReferences(rvalue, refName.docInfo, refName);
+    }
+      if (aliasingGets > 0) {","+    if (rvalue != null && rvalue.getType() == Token.FUNCTION) {
+      checkForHosedThisReferences(rvalue, refName.docInfo, refName);
+    }
-      if (type != Type.FUNCTION && aliasingGets > 0) {
+      if (aliasingGets > 0) {"
Closure 88,junit.framework.AssertionFailedError,condBlockRetAdd,,"+        Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);
+        Node rhs = n.getNext();
+        VariableLiveness state = isVariableReadBeforeKill(rhs, variable);
+        if (state == VariableLiveness.READ) {
+          return state;
+        }","+        Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);
+        Node rhs = n.getNext();
+        VariableLiveness state = isVariableReadBeforeKill(rhs, variable);
+        if (state == VariableLiveness.READ) {
+          return state;
+        }"
Closure 87,junit.framework.AssertionFailedError,"condBlockRetAdd
wrongComp",-          return NodeUtil.isExpressionNode(maybeExpr);,"+        if (maybeExpr.getType() == Token.EXPR_RESULT) {
+          if (maybeExpr.getFirstChild().getType() == Token.CALL) {
+            Node calledFn = maybeExpr.getFirstChild().getFirstChild();
+            if (calledFn.getType() == Token.GETELEM) {
+              return false;
+            } else if (calledFn.getType() == Token.GETPROP &&
+                       calledFn.getLastChild().getString().startsWith(""on"")) {
+              return false;
+            }
+          }
+          return true;
+        }
+        return false;","+        if (maybeExpr.getType() == Token.EXPR_RESULT) {
+          if (maybeExpr.getFirstChild().getType() == Token.CALL) {
+            Node calledFn = maybeExpr.getFirstChild().getFirstChild();
+            if (calledFn.getType() == Token.GETELEM) {
+              return false;
+            } else if (calledFn.getType() == Token.GETPROP &&
+                       calledFn.getLastChild().getString().startsWith(""on"")) {
+              return false;
+            }
+          }
-          return NodeUtil.isExpressionNode(maybeExpr);
+          return true;
+        }
+        return false;"
Closure 92,junit.framework.AssertionFailedError,"singleLine
wrongMethodRef",-          int indexOfDot = namespace.indexOf('.');,+          int indexOfDot = namespace.lastIndexOf('.');,"-          int indexOfDot = namespace.indexOf('.');
+          int indexOfDot = namespace.lastIndexOf('.');"
Closure 95,junit.framework.AssertionFailedError,"condBlockOthersAdd
missComp",,"+      if (n.getType() == Token.GETPROP && !scope.isGlobal() &&
+          isQnameRootedInGlobalScope(n)) {
+        Scope globalScope = scope.getGlobalScope();
+        if (!globalScope.isDeclared(variableName, false)) {
+          scopeToDeclareIn = scope.getGlobalScope();
+        }
+      }","+      if (n.getType() == Token.GETPROP && !scope.isGlobal() &&
+          isQnameRootedInGlobalScope(n)) {
+        Scope globalScope = scope.getGlobalScope();
+        if (!globalScope.isDeclared(variableName, false)) {
+          scopeToDeclareIn = scope.getGlobalScope();
+        }
+      }"
Closure 90,junit.framework.AssertionFailedError,"condBlockOthersAdd
missComp
missNullCheckN",-      if (!type.isSubtype(,"+      if (!type.restrictByNotNullOrUndefined().isSubtype(
+    if (maybeTypeOfThis != null) {
+      maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined();
+    }","-      if (!type.isSubtype(
+      if (!type.restrictByNotNullOrUndefined().isSubtype(
+    if (maybeTypeOfThis != null) {
+      maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined();
+    }"
Closure 94,junit.framework.AssertionFailedError,"condBlockRetAdd
expLogicExpand",,"+      case Token.ADD:
+      case Token.DIV:
+      case Token.EQ:
+      case Token.GE:
+      case Token.GT:
+      case Token.LE:
+      case Token.LSH:
+      case Token.LT:
+      case Token.MOD:
+      case Token.MUL:
+      case Token.NE:
+      case Token.RSH:
+      case Token.SHEQ:
+      case Token.SHNE:
+      case Token.SUB:
+      case Token.URSH:
+        return isValidDefineValue(val.getFirstChild(), defines)
+            && isValidDefineValue(val.getLastChild(), defines);
+      case Token.POS:","+      case Token.ADD:
+      case Token.DIV:
+      case Token.EQ:
+      case Token.GE:
+      case Token.GT:
+      case Token.LE:
+      case Token.LSH:
+      case Token.LT:
+      case Token.MOD:
+      case Token.MUL:
+      case Token.NE:
+      case Token.RSH:
+      case Token.SHEQ:
+      case Token.SHNE:
+      case Token.SUB:
+      case Token.URSH:
+        return isValidDefineValue(val.getFirstChild(), defines)
+            && isValidDefineValue(val.getLastChild(), defines);
+      case Token.POS:"
Closure 91,junit.framework.AssertionFailedError,"condBlockOthersAdd
condBlockRetAdd
missComp",,"+      Node gramps = parent.getParent();
+      if (NodeUtil.isObjectLitKey(parent, gramps)) {
+        JSDocInfo maybeLends = gramps.getJSDocInfo();
+        if (maybeLends != null &&
+            maybeLends.getLendsName() != null &&
+            maybeLends.getLendsName().endsWith("".prototype"")) {
+          return false;
+        }
+      }","+      Node gramps = parent.getParent();
+      if (NodeUtil.isObjectLitKey(parent, gramps)) {
+        JSDocInfo maybeLends = gramps.getJSDocInfo();
+        if (maybeLends != null &&
+            maybeLends.getLendsName() != null &&
+            maybeLends.getLendsName().endsWith("".prototype"")) {
+          return false;
+        }
+      }"
Closure 93,junit.framework.AssertionFailedError,"singleLine
wrongMethodRef",-          int indexOfDot = namespace.indexOf('.');,+          int indexOfDot = namespace.lastIndexOf('.');,"-          int indexOfDot = namespace.indexOf('.');
+          int indexOfDot = namespace.lastIndexOf('.');"
Closure 97,junit.framework.AssertionFailedError,"expArithMod
missComp
singleLine",-          result = lvalInt >>> rvalInt;,"+          long lvalLong = lvalInt & 0xffffffffL;
+          result = lvalLong >>> rvalInt;","-          result = lvalInt >>> rvalInt;
+          long lvalLong = lvalInt & 0xffffffffL;
+          result = lvalLong >>> rvalInt;"
Closure 96,junit.framework.AssertionFailedError,"expLogicExpand
missNullCheckN
wrapsIf",-           parameters.hasNext()) {,"+           (parameters.hasNext() ||
+            parameter != null && parameter.isVarArgs())) {
+      if (parameters.hasNext()) {
+      }","-           parameters.hasNext()) {
+           (parameters.hasNext() ||
+            parameter != null && parameter.isVarArgs())) {
+      if (parameters.hasNext()) {
+      }"
Closure 101,junit.framework.AssertionFailedError,condBlockRem,"-    if (flags.process_closure_primitives) {
-      options.closurePass = true;
-    }",+    options.closurePass = flags.process_closure_primitives;,"-    if (flags.process_closure_primitives) {
-      options.closurePass = true;
-    }
+    options.closurePass = flags.process_closure_primitives;"
Closure 100,junit.framework.AssertionFailedError,"condBlockRetAdd
missNullCheckN
wrongComp",-    return false;,"+      int pType = parent.getType();
+      if (!(pType == Token.BLOCK ||
+            pType == Token.SCRIPT ||
+            pType == Token.NAME ||
+            pType == Token.ASSIGN)) {
+        return false;
+      }
+    return parent != null && NodeUtil.isGet(parent);","+      int pType = parent.getType();
+      if (!(pType == Token.BLOCK ||
+            pType == Token.SCRIPT ||
+            pType == Token.NAME ||
+            pType == Token.ASSIGN)) {
+        return false;
+      }
-    return false;
+    return parent != null && NodeUtil.isGet(parent);"
Closure 98,junit.framework.AssertionFailedError,"condBlockOthersAdd
condBlockRetAdd
missComp
missNullCheckN",,"+      for (BasicBlock block = ref.getBasicBlock();
+           block != null; block = block.getParent()) {
+        if (block.isFunction) {
+          break;
+        } else if (block.isLoop) {
+          return false;
+        }
+      }
+    private final boolean isFunction;
+    private final boolean isLoop;
+      this.isFunction = root.getType() == Token.FUNCTION;
+      if (root.getParent() != null) {
+        int pType = root.getParent().getType();
+        this.isLoop = pType == Token.DO ||
+            pType == Token.WHILE ||
+            pType == Token.FOR;
+      } else {
+        this.isLoop = false;
+      }","+      for (BasicBlock block = ref.getBasicBlock();
+           block != null; block = block.getParent()) {
+        if (block.isFunction) {
+          break;
+        } else if (block.isLoop) {
+          return false;
+        }
+      }
+    private final boolean isFunction;
+    private final boolean isLoop;
+      this.isFunction = root.getType() == Token.FUNCTION;
+      if (root.getParent() != null) {
+        int pType = root.getParent().getType();
+        this.isLoop = pType == Token.DO ||
+            pType == Token.WHILE ||
+            pType == Token.FOR;
+      } else {
+        this.isLoop = false;
+      }"
Closure 99,junit.framework.AssertionFailedError,"expLogicExpand
expLogicMod
wrapsIf","-          if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains("".prototype."")) {","+           jsDoc.isInterface() ||
+        if (NodeUtil.isGet(lhs)) {
+          Node llhs = lhs.getFirstChild();
+          if (llhs.getType() == Token.GETPROP &&
+              llhs.getLastChild().getString().equals(""prototype"")) {
+        }","+           jsDoc.isInterface() ||
+        if (NodeUtil.isGet(lhs)) {
-          if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains("".prototype."")) {
+          Node llhs = lhs.getFirstChild();
+          if (llhs.getType() == Token.GETPROP &&
+              llhs.getLastChild().getString().equals(""prototype"")) {
+        }"
Closure 104,junit.framework.AssertionFailedError,"expLogicMod
singleLine",-    if (result != null) {,+    if (!result.isNoType()) {,"-    if (result != null) {
+    if (!result.isNoType()) {"
Closure 105,junit.framework.AssertionFailedError,"condBlockOthersAdd
copyPaste
expLogicMod
initFix","-    StringBuilder sb = new StringBuilder();
-        if (sb.length() > 0) {
-        if (sb.length() > 0) {
-          sb = new StringBuilder();
-    if (sb.length() > 0) {","+    StringBuilder sb = null;
+        if (sb == null) {
+          sb = new StringBuilder();
+        } else {
+        if (sb != null) {
+          sb = null;
+    if (sb != null) {","-    StringBuilder sb = new StringBuilder();
+    StringBuilder sb = null;
-        if (sb.length() > 0) {
+        if (sb == null) {
+          sb = new StringBuilder();
+        } else {
-        if (sb.length() > 0) {
+        if (sb != null) {
-          sb = new StringBuilder();
+          sb = null;
-    if (sb.length() > 0) {
+    if (sb != null) {"
Closure 106,junit.framework.AssertionFailedError,"condBlockRetAdd
missNullCheckN
unwrapIfElse","-    if (parseDocumentation) {
-    }","+      Preconditions.checkNotNull(declaration);
+      if (declaration.getTwin() != null) {
+        return false;
+      }","+      Preconditions.checkNotNull(declaration);
+      if (declaration.getTwin() != null) {
+        return false;
+      }
-    if (parseDocumentation) {
-    }"
Closure 102,junit.framework.AssertionFailedError,"codeMove
singleLine",-    removeDuplicateDeclarations(root);,+    removeDuplicateDeclarations(root);,"+    removeDuplicateDeclarations(root);
-    removeDuplicateDeclarations(root);"
Closure 103,junit.framework.AssertionFailedError,"condBlockOthersAdd
expLogicExpand
missNullCheckN
missNullCheckP",,"+      case Token.INSTANCEOF:
+      if (foundType == null) {
+        ObjectType maybeType = ObjectType.cast(
+            registry.getGreatestSubtypeWithProperty(type, field));
+        if (maybeType != null && maybeType.hasOwnProperty(field)) {
+          foundType = maybeType;
+        }
+      }","+      case Token.INSTANCEOF:
+      if (foundType == null) {
+        ObjectType maybeType = ObjectType.cast(
+            registry.getGreatestSubtypeWithProperty(type, field));
+        if (maybeType != null && maybeType.hasOwnProperty(field)) {
+          foundType = maybeType;
+        }
+      }"
Closure 107,junit.framework.AssertionFailedError,"missComp
singleLine",,"+      options.setWarningLevel(JsMessageVisitor.MSG_CONVENTIONS, CheckLevel.OFF);","+      options.setWarningLevel(JsMessageVisitor.MSG_CONVENTIONS, CheckLevel.OFF);"
Closure 108,java.lang.IllegalStateException,"expLogicExpand
initFix
missComp",-        if (info != null) {,"+    private final Set<Node> injectedDecls = Sets.newHashSet();
+        injectedDecls.clear();
+            injectedDecls.add(newDecl.getFirstChild());
+        if (info != null && !injectedDecls.contains(n)) {","+    private final Set<Node> injectedDecls = Sets.newHashSet();
+        injectedDecls.clear();
+            injectedDecls.add(newDecl.getFirstChild());
-        if (info != null) {
+        if (info != null && !injectedDecls.contains(n)) {"
Closure 109,junit.framework.AssertionFailedError,"condBlockRetAdd
wrapsIfElse
wrongComp
wrongMethodRef",-          return parseTypeName(token);,"+    if (token == JsDocToken.QMARK) {
+      return newNode(Token.QMARK);
+    } else {
+      return parseBasicTypeExpression(token);
+    }","-          return parseTypeName(token);
+    if (token == JsDocToken.QMARK) {
+      return newNode(Token.QMARK);
+    } else {
+      return parseBasicTypeExpression(token);
+    }"
Closure 117,junit.framework.ComparisonFailure,codeMove,"-    JSType type = getJSType(n);
-    if (dereference) {
-      ObjectType dereferenced = type.dereference();
-      if (dereferenced != null) {
-        type = dereferenced;
-      }
-    }
-    if (type.isFunctionPrototypeType() ||
-        (type.toObjectType() != null &&
-         type.toObjectType().getConstructor() != null)) {
-      return type.toString();
-    }","+    JSType type = getJSType(n);
+    if (dereference) {
+      ObjectType dereferenced = type.dereference();
+      if (dereferenced != null) {
+        type = dereferenced;
+      }
+    }
+    if (type.isFunctionPrototypeType() ||
+        (type.toObjectType() != null &&
+         type.toObjectType().getConstructor() != null)) {
+      return type.toString();
+    }","+    JSType type = getJSType(n);
+    if (dereference) {
+      ObjectType dereferenced = type.dereference();
+      if (dereferenced != null) {
+        type = dereferenced;
+      }
+    }
+    if (type.isFunctionPrototypeType() ||
+        (type.toObjectType() != null &&
+         type.toObjectType().getConstructor() != null)) {
+      return type.toString();
+    }
-    JSType type = getJSType(n);
-    if (dereference) {
-      ObjectType dereferenced = type.dereference();
-      if (dereferenced != null) {
-        type = dereferenced;
-      }
-    }
-    if (type.isFunctionPrototypeType() ||
-        (type.toObjectType() != null &&
-         type.toObjectType().getConstructor() != null)) {
-      return type.toString();
-    }"
Closure 112,junit.framework.AssertionFailedError,wrapsMethod,"-    Map<TemplateType, JSType> inferred = 
-        inferTemplateTypesFromParameters(fnType, n);","+    Map<TemplateType, JSType> inferred = Maps.filterKeys(
+        inferTemplateTypesFromParameters(fnType, n),
+        new Predicate<TemplateType>() {
+          @Override
+          public boolean apply(TemplateType key) {
+            return keys.contains(key);
+          }}
+        );","-    Map<TemplateType, JSType> inferred = 
-        inferTemplateTypesFromParameters(fnType, n);
+    Map<TemplateType, JSType> inferred = Maps.filterKeys(
+        inferTemplateTypesFromParameters(fnType, n),
+        new Predicate<TemplateType>() {
+          @Override
+          public boolean apply(TemplateType key) {
+            return keys.contains(key);
+          }}
+        );"
Closure 114,junit.framework.AssertionFailedError,"singleLine
wrapsIf",-        } else {,+        } else if (!(parent.isCall() && parent.getFirstChild() == n)) {,"-        } else {
+        } else if (!(parent.isCall() && parent.getFirstChild() == n)) {"
Closure 113,junit.framework.AssertionFailedError,"expLogicExpand
singleLine",-      if (provided != null) {,+      if (provided != null || requiresLevel.isOn()) {,"-      if (provided != null) {
+      if (provided != null || requiresLevel.isOn()) {"
Closure 115,junit.framework.AssertionFailedError,"blockRemove
condBlockRem","-    boolean hasSideEffects = false;
-    if (block.hasChildren()) {
-      Preconditions.checkState(block.hasOneChild());
-      Node stmt = block.getFirstChild();
-      if (stmt.isReturn()) {
-        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);
-      }
-    }
-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {
-            return CanInlineResult.NO;
-          }",,"-    boolean hasSideEffects = false;
-    if (block.hasChildren()) {
-      Preconditions.checkState(block.hasOneChild());
-      Node stmt = block.getFirstChild();
-      if (stmt.isReturn()) {
-        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);
-      }
-    }
-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {
-            return CanInlineResult.NO;
-          }"
Closure 116,junit.framework.AssertionFailedError,"condBlockOthersAdd
condBlockRetAdd
missComp",,"+    boolean hasSideEffects = false;  // empty function case
+    if (block.hasChildren()) {
+      Preconditions.checkState(block.hasOneChild());
+      Node stmt = block.getFirstChild();
+      if (stmt.isReturn()) {
+        hasSideEffects = NodeUtil.mayHaveSideEffects(
+            stmt.getFirstChild(), compiler);
+      }
+    }
+          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {
+            return CanInlineResult.NO;
+          }","+    boolean hasSideEffects = false;  // empty function case
+    if (block.hasChildren()) {
+      Preconditions.checkState(block.hasOneChild());
+      Node stmt = block.getFirstChild();
+      if (stmt.isReturn()) {
+        hasSideEffects = NodeUtil.mayHaveSideEffects(
+            stmt.getFirstChild(), compiler);
+      }
+    }
+          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {
+            return CanInlineResult.NO;
+          }"
Closure 111,junit.framework.AssertionFailedError,"singleLine
wrapsIfElse",-          return topType;,"+          return topType.isAllType() ?
+              getNativeType(ARRAY_TYPE) : topType;","-          return topType;
+          return topType.isAllType() ?
+              getNativeType(ARRAY_TYPE) : topType;"
Closure 110,junit.framework.AssertionFailedError,"condBlockExcAdd
condBlockOthersAdd
expLogicExpand
expLogicMod
initFix
missNullCheckN
missNullCheckP
wrapsIfElse","-        } else if (isVar) {
-          Node value = n.hasChildren() ?
-              v.getInitialValue().detachFromParent() :
-          Node varNode = parent;","+        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);
+        } else if (isVar || isFunctionDecl) {
+          boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);
+          Node value = v.getInitialValue() != null ?
+              v.getInitialValue() :
+          Node varNode = null;
+          if (isFunctionDecl) {
+            Node existingName = v.getNameNode();
+            Node newName = IR.name("""").useSourceInfoFrom(existingName);
+            value.replaceChild(existingName, newName);
+            varNode = IR.var(existingName).useSourceInfoFrom(existingName);
+            grandparent.replaceChild(parent, varNode);
+          } else {
+            if (value != null) {
+              value.detachFromParent();
+            }
+            varNode = parent;
+          }
+            if (isHoisted) {
+              grandparent.addChildToFront(newDecl);
+            } else {
+            }
+    if (n == null) {
+      throw new RuntimeException(""node is not a child"");
+    }","+        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);
-        } else if (isVar) {
+        } else if (isVar || isFunctionDecl) {
+          boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);
-          Node value = n.hasChildren() ?
-              v.getInitialValue().detachFromParent() :
+          Node value = v.getInitialValue() != null ?
+              v.getInitialValue() :
-          Node varNode = parent;
+          Node varNode = null;
+          if (isFunctionDecl) {
+            Node existingName = v.getNameNode();
+            Node newName = IR.name("""").useSourceInfoFrom(existingName);
+            value.replaceChild(existingName, newName);
+            varNode = IR.var(existingName).useSourceInfoFrom(existingName);
+            grandparent.replaceChild(parent, varNode);
+          } else {
+            if (value != null) {
+              value.detachFromParent();
+            }
+            varNode = parent;
+          }
+            if (isHoisted) {
+              grandparent.addChildToFront(newDecl);
+            } else {
+            }
+    if (n == null) {
+      throw new RuntimeException(""node is not a child"");
+    }"
Closure 118,junit.framework.ComparisonFailure,condBlockOthersAdd,,"+        if (child.isQuotedString()) {
+          continue;
+        }","+        if (child.isQuotedString()) {
+          continue;
+        }"
Closure 120,junit.framework.AssertionFailedError,condBlockRetAdd,,"+          if (ref.getSymbol().getScope() != ref.scope) {
+            return false;
+          }","+          if (ref.getSymbol().getScope() != ref.scope) {
+            return false;
+          }"
Closure 119,junit.framework.AssertionFailedError,"expLogicExpand
singleLine",,+              case Token.CATCH:,+              case Token.CATCH:
Closure 121,junit.framework.AssertionFailedError,"expLogicExpand
singleLine",-          referenceInfo.isAssignedOnceInLifetime()) {,"+          referenceInfo.isAssignedOnceInLifetime() &&
+          (isInlineableDeclaredConstant(v, referenceInfo) ||
+           referenceInfo.isOnlyAssignmentSameScopeAsDeclaration())) {","-          referenceInfo.isAssignedOnceInLifetime()) {
+          referenceInfo.isAssignedOnceInLifetime() &&
+          (isInlineableDeclaredConstant(v, referenceInfo) ||
+           referenceInfo.isOnlyAssignmentSameScopeAsDeclaration())) {"
Closure 123,junit.framework.ComparisonFailure,"initFix
singleLine
wrongComp
wrongVarRef",-        Context rhsContext = Context.OTHER;,+        Context rhsContext = getContextForNoInOperator(context);,"-        Context rhsContext = Context.OTHER;
+        Context rhsContext = getContextForNoInOperator(context);"
Closure 122,junit.framework.AssertionFailedError,"expLogicMod
wrongComp","-    if (comment.getValue().indexOf(""/* @"") != -1 || comment.getValue().indexOf(""\n * @"") != -1) {","+    Pattern p = Pattern.compile(""(/|(\n[ \t]*))\\*[ \t]*@[a-zA-Z]"");
+    if (p.matcher(comment.getValue()).find()) {","-    if (comment.getValue().indexOf(""/* @"") != -1 || comment.getValue().indexOf(""\n * @"") != -1) {
+    Pattern p = Pattern.compile(""(/|(\n[ \t]*))\\*[ \t]*@[a-zA-Z]"");
+    if (p.matcher(comment.getValue()).find()) {"
Closure 126,junit.framework.AssertionFailedError,condBlockRem,"-      if (NodeUtil.hasFinally(n)) {
-        Node finallyBlock = n.getLastChild();
-        tryMinimizeExits(finallyBlock, exitType, labelName);
-      }",,"-      if (NodeUtil.hasFinally(n)) {
-        Node finallyBlock = n.getLastChild();
-        tryMinimizeExits(finallyBlock, exitType, labelName);
-      }"
Closure 124,junit.framework.AssertionFailedError,"missComp
wrapsLoop",,"+    while (node.isGetProp()) {
+    }","+    while (node.isGetProp()) {
+    }"
Closure 127,junit.framework.AssertionFailedError,"condBlockRetAdd
expLogicExpand
missComp
missNullCheckP",-            if (nextCfgNode == fallThrough) {,"+            if (nextCfgNode == fallThrough && !inFinally(n.getParent(), n)) {
+    private boolean inFinally(Node parent, Node child) {
+      if (parent == null || parent.isFunction()) {
+        return false;
+      } else if (NodeUtil.isTryFinallyNode(parent, child)) {
+        return true;
+      } else {
+        return inFinally(parent.getParent(), parent);
+      }
+    }","-            if (nextCfgNode == fallThrough) {
+            if (nextCfgNode == fallThrough && !inFinally(n.getParent(), n)) {
+    private boolean inFinally(Node parent, Node child) {
+      if (parent == null || parent.isFunction()) {
+        return false;
+      } else if (NodeUtil.isTryFinallyNode(parent, child)) {
+        return true;
+      } else {
+        return inFinally(parent.getParent(), parent);
+      }
+    }"
Closure 125,java.lang.IllegalStateException,"expLogicExpand
singleLine",-      if (fnType != null) {,+      if (fnType != null && fnType.hasInstanceType()) {,"-      if (fnType != null) {
+      if (fnType != null && fnType.hasInstanceType()) {"
Closure 128,junit.framework.ComparisonFailure,"condBlockRetAdd
expLogicMod",-    return len > 0 && s.charAt(0) != '0';,"+    if (len == 0) {
+      return false;
+    }
+    return len == 1 || s.charAt(0) != '0';","+    if (len == 0) {
+      return false;
+    }
-    return len > 0 && s.charAt(0) != '0';
+    return len == 1 || s.charAt(0) != '0';"
Lang 3,junit.framework.AssertionFailedError,"copyPaste
wrapsIf",,"+            if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float
+            }
+            if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double
+            }","+            if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float
+            }
+            if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double
+            }"
Lang 2,junit.framework.AssertionFailedError,condBlockExcAdd,,"+        if (str.contains(""#"")) { // LANG-879 - Cannot handle Java 7 script & extensions
+            throw new IllegalArgumentException(""Invalid locale format: "" + str);
+        }","+        if (str.contains(""#"")) { // LANG-879 - Cannot handle Java 7 script & extensions
+            throw new IllegalArgumentException(""Invalid locale format: "" + str);
+        }"
Lang 5,java.lang.IllegalArgumentException,"condBlockExcAdd
condBlockRetAdd
wrapsIfElse",,"+        if (ch0 == '_') {
+            if (len < 3) {
+                throw new IllegalArgumentException(""Invalid locale format: "" + str);
+            }
+            final char ch1 = str.charAt(1);
+            final char ch2 = str.charAt(2);
+            if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {
+                throw new IllegalArgumentException(""Invalid locale format: "" + str);
+            }
+            if (len == 3) {
+                return new Locale("""", str.substring(1, 3));
+            }
+            if (len < 5) {
+                throw new IllegalArgumentException(""Invalid locale format: "" + str);
+            }
+            if (str.charAt(3) != '_') {
+                throw new IllegalArgumentException(""Invalid locale format: "" + str);
+            }
+            return new Locale("""", str.substring(1, 3), str.substring(4));
+        } else {
+        }","+        if (ch0 == '_') {
+            if (len < 3) {
+                throw new IllegalArgumentException(""Invalid locale format: "" + str);
+            }
+            final char ch1 = str.charAt(1);
+            final char ch2 = str.charAt(2);
+            if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {
+                throw new IllegalArgumentException(""Invalid locale format: "" + str);
+            }
+            if (len == 3) {
+                return new Locale("""", str.substring(1, 3));
+            }
+            if (len < 5) {
+                throw new IllegalArgumentException(""Invalid locale format: "" + str);
+            }
+            if (str.charAt(3) != '_') {
+                throw new IllegalArgumentException(""Invalid locale format: "" + str);
+            }
+            return new Locale("""", str.substring(1, 3), str.substring(4));
+        } else {
+        }"
Closure 130,junit.framework.AssertionFailedError,"expLogicExpand
singleLine",-      if (name.globalSets == 1 && name.localSets == 0 &&,+      if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 &&,"-      if (name.globalSets == 1 && name.localSets == 0 &&
+      if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 &&"
Lang 4,junit.framework.AssertionFailedError,"initFix
wrongVarRef","-    private final HashMap<CharSequence, CharSequence> lookupMap;
-        lookupMap = new HashMap<CharSequence, CharSequence>();
-                this.lookupMap.put(seq[0], seq[1]);
-            final CharSequence result = lookupMap.get(subSeq);","+    private final HashMap<String, CharSequence> lookupMap;
+        lookupMap = new HashMap<String, CharSequence>();
+                this.lookupMap.put(seq[0].toString(), seq[1]);
+            final CharSequence result = lookupMap.get(subSeq.toString());","-    private final HashMap<CharSequence, CharSequence> lookupMap;
+    private final HashMap<String, CharSequence> lookupMap;
-        lookupMap = new HashMap<CharSequence, CharSequence>();
+        lookupMap = new HashMap<String, CharSequence>();
-                this.lookupMap.put(seq[0], seq[1]);
+                this.lookupMap.put(seq[0].toString(), seq[1]);
-            final CharSequence result = lookupMap.get(subSeq);
+            final CharSequence result = lookupMap.get(subSeq.toString());"
Closure 129,junit.framework.AssertionFailedError,"missComp
notClassified",,"+      while (first.isCast()) {
+        first = first.getFirstChild();
+      }","+      while (first.isCast()) {
+        first = first.getFirstChild();
+      }"
Lang 1,java.lang.NumberFormatException,"condBlockOthersAdd
copyPaste
expLogicExpand
missComp","-            if (hexDigits > 16) { // too many for Long
-            if (hexDigits > 8) { // too many for an int","+            char firstSigDigit = 0; // strip leading zeroes
+            for(int i = pfxLen; i < str.length(); i++) {
+                firstSigDigit = str.charAt(i);
+                if (firstSigDigit == '0') { // count leading zeroes
+                    pfxLen++;
+                } else {
+                    break;
+                }
+            }
+            if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { // too many for Long
+            if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { // too many for an int","+            char firstSigDigit = 0; // strip leading zeroes
+            for(int i = pfxLen; i < str.length(); i++) {
+                firstSigDigit = str.charAt(i);
+                if (firstSigDigit == '0') { // count leading zeroes
+                    pfxLen++;
+                } else {
+                    break;
+                }
+            }
-            if (hexDigits > 16) { // too many for Long
+            if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { // too many for Long
-            if (hexDigits > 8) { // too many for an int
+            if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { // too many for an int"
Closure 132,junit.framework.AssertionFailedError,"expLogicExpand
singleLine",-              !mayEffectMutableState(lhs)) {,"+              !mayEffectMutableState(lhs) &&
+              (!mayHaveSideEffects(cond) ||
+                  (thenOp.isAssign() && thenOp.getFirstChild().isName()))) {","-              !mayEffectMutableState(lhs)) {
+              !mayEffectMutableState(lhs) &&
+              (!mayHaveSideEffects(cond) ||
+                  (thenOp.isAssign() && thenOp.getFirstChild().isName()))) {"
Lang 6,java.lang.StringIndexOutOfBoundsException,"expArithMod
singleLine
wrongVarRef","-                pos += Character.charCount(Character.codePointAt(input, pos));","+                pos += Character.charCount(Character.codePointAt(input, pt));","-                pos += Character.charCount(Character.codePointAt(input, pos));
+                pos += Character.charCount(Character.codePointAt(input, pt));"
Closure 133,java.lang.IllegalStateException,"missComp
singleLine",,+    unreadToken = NO_UNREAD_TOKEN;,+    unreadToken = NO_UNREAD_TOKEN;
Lang 7,junit.framework.AssertionFailedError,"blockRemove
condBlockExcAdd
condBlockRem","-        if (str.startsWith(""--"")) {
-            return null;
-        }","+        if (str.trim().startsWith(""--"")) {
+            throw new NumberFormatException(str + "" is not a valid number."");
+        }","-        if (str.startsWith(""--"")) {
-            return null;
-        }
+        if (str.trim().startsWith(""--"")) {
+            throw new NumberFormatException(str + "" is not a valid number."");
+        }"
Closure 131,junit.framework.AssertionFailedError,"copyPaste
expLogicExpand",-        if (,"+          Character.isIdentifierIgnorable(s.charAt(0)) ||
+        if (Character.isIdentifierIgnorable(s.charAt(i)) ||","+          Character.isIdentifierIgnorable(s.charAt(0)) ||
-        if (
+        if (Character.isIdentifierIgnorable(s.charAt(i)) ||"
Lang 8,junit.framework.AssertionFailedError,"initFix
notClassified
wrongComp","-        private final TimeZone zone;
-            zone = timeZone;",+            TimeZone zone = calendar.getTimeZone();,"-        private final TimeZone zone;
-            zone = timeZone;
+            TimeZone zone = calendar.getTimeZone();"
Lang 10,junit.framework.AssertionFailedError,condBlockRem,"-        boolean wasWhite= false;
-            if(Character.isWhitespace(c)) {
-                if(!wasWhite) {
-                    wasWhite= true;
-                    regex.append(""\\s*+"");
-                }
-                continue;
-            }
-            wasWhite= false;",,"-        boolean wasWhite= false;
-            if(Character.isWhitespace(c)) {
-                if(!wasWhite) {
-                    wasWhite= true;
-                    regex.append(""\\s*+"");
-                }
-                continue;
-            }
-            wasWhite= false;"
Lang 11,junit.framework.AssertionFailedError,"condBlockExcAdd
condBlockOthersAdd",,"+        } else {
+            if (end <= start) {
+                throw new IllegalArgumentException(""Parameter end ("" + end + "") must be greater than start ("" + start + "")"");
+            }","+        } else {
+            if (end <= start) {
+                throw new IllegalArgumentException(""Parameter end ("" + end + "") must be greater than start ("" + start + "")"");
+            }"
Lang 9,junit.framework.AssertionFailedError,condBlockExcAdd,,"+        if (patternMatcher.regionStart() != patternMatcher.regionEnd()) {
+            throw new IllegalArgumentException(""Failed to parse \""""+pattern+""\"" ; gave up at index ""+patternMatcher.regionStart());
+        }","+        if (patternMatcher.regionStart() != patternMatcher.regionEnd()) {
+            throw new IllegalArgumentException(""Failed to parse \""""+pattern+""\"" ; gave up at index ""+patternMatcher.regionStart());
+        }"
Lang 13,org.apache.commons.lang3.SerializationException,"condBlockExcAdd
condBlockRetAdd
initFix
wrapsTryCatch",,"+        private static final Map<String, Class<?>> primitiveTypes = 
+                new HashMap<String, Class<?>>();
+            primitiveTypes.put(""byte"", byte.class);
+            primitiveTypes.put(""short"", short.class);
+            primitiveTypes.put(""int"", int.class);
+            primitiveTypes.put(""long"", long.class);
+            primitiveTypes.put(""float"", float.class);
+            primitiveTypes.put(""double"", double.class);
+            primitiveTypes.put(""boolean"", boolean.class);
+            primitiveTypes.put(""char"", char.class);
+            primitiveTypes.put(""void"", void.class);
+                try {
+                } catch (ClassNotFoundException cnfe) {
+                    Class<?> cls = primitiveTypes.get(name);
+                    if (cls != null)
+                        return cls;
+                    else
+                        throw cnfe;
+                }","+        private static final Map<String, Class<?>> primitiveTypes = 
+                new HashMap<String, Class<?>>();
+            primitiveTypes.put(""byte"", byte.class);
+            primitiveTypes.put(""short"", short.class);
+            primitiveTypes.put(""int"", int.class);
+            primitiveTypes.put(""long"", long.class);
+            primitiveTypes.put(""float"", float.class);
+            primitiveTypes.put(""double"", double.class);
+            primitiveTypes.put(""boolean"", boolean.class);
+            primitiveTypes.put(""char"", char.class);
+            primitiveTypes.put(""void"", void.class);
+                try {
+                } catch (ClassNotFoundException cnfe) {
+                    Class<?> cls = primitiveTypes.get(name);
+                    if (cls != null)
+                        return cls;
+                    else
+                        throw cnfe;
+                }"
Lang 12,java.lang.ArrayIndexOutOfBoundsException,"condBlockExcAdd
missNullCheckN
wrapsIfElse",,"+        if (chars != null && chars.length == 0) {
+            throw new IllegalArgumentException(""The chars array must not be empty"");
+        }
+            if (chars != null) {
+                end = chars.length;
+            } else {
+            }","+        if (chars != null && chars.length == 0) {
+            throw new IllegalArgumentException(""The chars array must not be empty"");
+        }
+            if (chars != null) {
+                end = chars.length;
+            } else {
+            }"
Lang 18,junit.framework.ComparisonFailure,"expLogicMod
wrapsIfElse","-                if (tokenLen >= 4) {
-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);
-                } else {","+                if (tokenLen == 2) {
+                } else {
+                    rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen);","-                if (tokenLen >= 4) {
-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);
-                } else {
+                if (tokenLen == 2) {
+                } else {
+                    rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen);"
Lang 17,junit.framework.ComparisonFailure,"initFix
missComp
unwrapIfElse
unwrapMethod","-        int len = Character.codePointCount(input, 0, input.length());
-            else {
-                    if (pos < len - 2) {
-                    } else {
-                        pos++;
-                    }
-                }
-                pos--;
-            pos++;","+        int len = input.length();
+                pos+= c.length;
+                continue;","-        int len = Character.codePointCount(input, 0, input.length());
+        int len = input.length();
+                pos+= c.length;
+                continue;
-            else {
-                    if (pos < len - 2) {
-                    } else {
-                        pos++;
-                    }
-                }
-                pos--;
-            pos++;"
Lang 14,junit.framework.AssertionFailedError,wrapsIf,,"+        if (cs1 instanceof String && cs2 instanceof String) {
+        }
+        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));","+        if (cs1 instanceof String && cs2 instanceof String) {
+        }
+        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));"
Lang 16,java.lang.NumberFormatException,"expLogicExpand
singleLine","-        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {","+        if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) {","-        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
+        if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) {"
Lang 15,junit.framework.AssertionFailedError,"expLogicReduce
wrongMethodRef","-        for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {
-            Type toTypeArg = entry.getValue();
-            Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());
-        if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) {","+        for (TypeVariable<?> var : toTypeVarAssigns.keySet()) {
+            Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns);
+            Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns);
+        if (toClass.equals(cls)) {","-        for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {
-            Type toTypeArg = entry.getValue();
-            Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());
+        for (TypeVariable<?> var : toTypeVarAssigns.keySet()) {
+            Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns);
+            Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns);
-        if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) {
+        if (toClass.equals(cls)) {"
Lang 21,junit.framework.AssertionFailedError,"constChange
expLogicMod
singleLine
wrongVarRef",-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&,+                cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&,"-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&
+                cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&"
Lang 19,java.lang.StringIndexOutOfBoundsException,"condBlockRetAdd
constChange
expArithMod
expLogicMod
wrapsIfElse","-        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
-            while(input.charAt(end) != ';') 
-            return 2 + (end - start) + (isHex ? 1 : 0) + 1;","+        if(input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {
+                if(start == seqEnd) {
+                    return 0;
+                }
+            while(end < seqEnd && ( (input.charAt(end) >= '0' && input.charAt(end) <= '9') ||
+                                    (input.charAt(end) >= 'a' && input.charAt(end) <= 'f') ||
+                                    (input.charAt(end) >= 'A' && input.charAt(end) <= 'F') ) )
+            boolean semiNext = (end != seqEnd) && (input.charAt(end) == ';');
+            return 2 + (end - start) + (isHex ? 1 : 0) + (semiNext ? 1 : 0);","-        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
+        if(input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {
+                if(start == seqEnd) {
+                    return 0;
+                }
-            while(input.charAt(end) != ';') 
+            while(end < seqEnd && ( (input.charAt(end) >= '0' && input.charAt(end) <= '9') ||
+                                    (input.charAt(end) >= 'a' && input.charAt(end) <= 'f') ||
+                                    (input.charAt(end) >= 'A' && input.charAt(end) <= 'F') ) )
+            boolean semiNext = (end != seqEnd) && (input.charAt(end) == ';');
-            return 2 + (end - start) + (isHex ? 1 : 0) + 1;
+            return 2 + (end - start) + (isHex ? 1 : 0) + (semiNext ? 1 : 0);"
Lang 23,junit.framework.AssertionFailedError,"condBlockRetAdd
fixAPI
wrongComp",,"+    private static final int HASH_SEED = 31;
+    @Override
+    public boolean equals(Object obj) {
+        if (obj == this) {
+            return true;
+        }
+        if (obj == null) {
+            return false;
+        }
+        if (!super.equals(obj)) {
+            return false;
+        }
+        if (ObjectUtils.notEqual(getClass(), obj.getClass())) {
+          return false;
+        }
+        ExtendedMessageFormat rhs = (ExtendedMessageFormat)obj;
+        if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) {
+            return false;
+        }
+        if (ObjectUtils.notEqual(registry, rhs.registry)) {
+            return false;
+        }
+        return true;
+    }
+    @Override
+    public int hashCode() {
+        int result = super.hashCode();
+        result = HASH_SEED * result + ObjectUtils.hashCode(registry);
+        result = HASH_SEED * result + ObjectUtils.hashCode(toPattern);
+        return result;
+    }","+    private static final int HASH_SEED = 31;
+    @Override
+    public boolean equals(Object obj) {
+        if (obj == this) {
+            return true;
+        }
+        if (obj == null) {
+            return false;
+        }
+        if (!super.equals(obj)) {
+            return false;
+        }
+        if (ObjectUtils.notEqual(getClass(), obj.getClass())) {
+          return false;
+        }
+        ExtendedMessageFormat rhs = (ExtendedMessageFormat)obj;
+        if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) {
+            return false;
+        }
+        if (ObjectUtils.notEqual(registry, rhs.registry)) {
+            return false;
+        }
+        return true;
+    }
+    @Override
+    public int hashCode() {
+        int result = super.hashCode();
+        result = HASH_SEED * result + ObjectUtils.hashCode(registry);
+        result = HASH_SEED * result + ObjectUtils.hashCode(toPattern);
+        return result;
+    }"
Lang 22,junit.framework.AssertionFailedError,"condBlockExcAdd
condBlockRetAdd
expLogicMod
missComp",-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {,"+        if ((u == 0) || (v == 0)) {
+            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {
+                throw new ArithmeticException(""overflow: gcd is 2^31"");
+            }
+            return Math.abs(u) + Math.abs(v);
+        }
+        if (Math.abs(u) == 1 || Math.abs(v) == 1) {","+        if ((u == 0) || (v == 0)) {
+            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {
+                throw new ArithmeticException(""overflow: gcd is 2^31"");
+            }
+            return Math.abs(u) + Math.abs(v);
+        }
-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {
+        if (Math.abs(u) == 1 || Math.abs(v) == 1) {"
Lang 20,java.lang.NullPointerException,"condBlockRem
copyPaste
initFix","-        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);
-        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());","+        StringBuilder buf = new StringBuilder(noOfItems * 16);
+        StringBuilder buf = new StringBuilder(noOfItems * 16);","-        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);
+        StringBuilder buf = new StringBuilder(noOfItems * 16);
-        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());
+        StringBuilder buf = new StringBuilder(noOfItems * 16);"
Lang 24,junit.framework.AssertionFailedError,"expLogicExpand
singleLine",-                return foundDigit && !hasExp;,+                return foundDigit && !hasExp && !hasDecPoint;,"-                return foundDigit && !hasExp;
+                return foundDigit && !hasExp && !hasDecPoint;"
Lang 26,junit.framework.ComparisonFailure,"initFix
singleLine
wrongMethodRef",-        Calendar c = new GregorianCalendar(mTimeZone);,"+        Calendar c = new GregorianCalendar(mTimeZone, mLocale);","-        Calendar c = new GregorianCalendar(mTimeZone);
+        Calendar c = new GregorianCalendar(mTimeZone, mLocale);"
Lang 25,junit.framework.AssertionFailedError,"constChange
initFix","-        {""\u00CB"", ""&Ecirc;""}, // � - uppercase E, circumflex accent
-        {""\u00CC"", ""&Euml;""}, // � - uppercase E, umlaut
-        {""\u00CD"", ""&Igrave;""}, // � - uppercase I, grave accent
-        {""\u00CE"", ""&Iacute;""}, // � - uppercase I, acute accent
-        {""\u00CF"", ""&Icirc;""}, // � - uppercase I, circumflex accent
-        {""\u00D0"", ""&Iuml;""}, // � - uppercase I, umlaut
-        {""\u00D1"", ""&ETH;""}, // � - uppercase Eth, Icelandic
-        {""\u00D2"", ""&Ntilde;""}, // � - uppercase N, tilde
-        {""\u00D3"", ""&Ograve;""}, // � - uppercase O, grave accent
-        {""\u00D4"", ""&Oacute;""}, // � - uppercase O, acute accent
-        {""\u00D5"", ""&Ocirc;""}, // � - uppercase O, circumflex accent
-        {""\u00D6"", ""&Otilde;""}, // � - uppercase O, tilde
-        {""\u00D7"", ""&Ouml;""}, // � - uppercase O, umlaut
-        {""\u00D8"", ""&times;""}, // multiplication sign
-        {""\u00D9"", ""&Oslash;""}, // � - uppercase O, slash
-        {""\u00DA"", ""&Ugrave;""}, // � - uppercase U, grave accent
-        {""\u00DB"", ""&Uacute;""}, // � - uppercase U, acute accent
-        {""\u00DC"", ""&Ucirc;""}, // � - uppercase U, circumflex accent
-        {""\u00DD"", ""&Uuml;""}, // � - uppercase U, umlaut
-        {""\u00DE"", ""&Yacute;""}, // � - uppercase Y, acute accent
-        {""\u00DF"", ""&THORN;""}, // � - uppercase THORN, Icelandic
-        {""\u00E0"", ""&szlig;""}, // � - lowercase sharps, German
-        {""\u00E1"", ""&agrave;""}, // � - lowercase a, grave accent
-        {""\u00E2"", ""&aacute;""}, // � - lowercase a, acute accent
-        {""\u00E3"", ""&acirc;""}, // � - lowercase a, circumflex accent
-        {""\u00E4"", ""&atilde;""}, // � - lowercase a, tilde
-        {""\u00E5"", ""&auml;""}, // � - lowercase a, umlaut","+        {""\u00CA"", ""&Ecirc;""}, // � - uppercase E, circumflex accent
+        {""\u00CB"", ""&Euml;""}, // � - uppercase E, umlaut
+        {""\u00CC"", ""&Igrave;""}, // � - uppercase I, grave accent
+        {""\u00CD"", ""&Iacute;""}, // � - uppercase I, acute accent
+        {""\u00CE"", ""&Icirc;""}, // � - uppercase I, circumflex accent
+        {""\u00CF"", ""&Iuml;""}, // � - uppercase I, umlaut
+        {""\u00D0"", ""&ETH;""}, // � - uppercase Eth, Icelandic
+        {""\u00D1"", ""&Ntilde;""}, // � - uppercase N, tilde
+        {""\u00D2"", ""&Ograve;""}, // � - uppercase O, grave accent
+        {""\u00D3"", ""&Oacute;""}, // � - uppercase O, acute accent
+        {""\u00D4"", ""&Ocirc;""}, // � - uppercase O, circumflex accent
+        {""\u00D5"", ""&Otilde;""}, // � - uppercase O, tilde
+        {""\u00D6"", ""&Ouml;""}, // � - uppercase O, umlaut
+        {""\u00D7"", ""&times;""}, // multiplication sign
+        {""\u00D8"", ""&Oslash;""}, // � - uppercase O, slash
+        {""\u00D9"", ""&Ugrave;""}, // � - uppercase U, grave accent
+        {""\u00DA"", ""&Uacute;""}, // � - uppercase U, acute accent
+        {""\u00DB"", ""&Ucirc;""}, // � - uppercase U, circumflex accent
+        {""\u00DC"", ""&Uuml;""}, // � - uppercase U, umlaut
+        {""\u00DD"", ""&Yacute;""}, // � - uppercase Y, acute accent
+        {""\u00DE"", ""&THORN;""}, // � - uppercase THORN, Icelandic
+        {""\u00DF"", ""&szlig;""}, // � - lowercase sharps, German
+        {""\u00E0"", ""&agrave;""}, // � - lowercase a, grave accent
+        {""\u00E1"", ""&aacute;""}, // � - lowercase a, acute accent
+        {""\u00E2"", ""&acirc;""}, // � - lowercase a, circumflex accent
+        {""\u00E3"", ""&atilde;""}, // � - lowercase a, tilde
+        {""\u00E4"", ""&auml;""}, // � - lowercase a, umlaut","-        {""\u00CB"", ""&Ecirc;""}, // � - uppercase E, circumflex accent
-        {""\u00CC"", ""&Euml;""}, // � - uppercase E, umlaut
-        {""\u00CD"", ""&Igrave;""}, // � - uppercase I, grave accent
-        {""\u00CE"", ""&Iacute;""}, // � - uppercase I, acute accent
-        {""\u00CF"", ""&Icirc;""}, // � - uppercase I, circumflex accent
-        {""\u00D0"", ""&Iuml;""}, // � - uppercase I, umlaut
-        {""\u00D1"", ""&ETH;""}, // � - uppercase Eth, Icelandic
-        {""\u00D2"", ""&Ntilde;""}, // � - uppercase N, tilde
-        {""\u00D3"", ""&Ograve;""}, // � - uppercase O, grave accent
-        {""\u00D4"", ""&Oacute;""}, // � - uppercase O, acute accent
-        {""\u00D5"", ""&Ocirc;""}, // � - uppercase O, circumflex accent
-        {""\u00D6"", ""&Otilde;""}, // � - uppercase O, tilde
-        {""\u00D7"", ""&Ouml;""}, // � - uppercase O, umlaut
-        {""\u00D8"", ""&times;""}, // multiplication sign
-        {""\u00D9"", ""&Oslash;""}, // � - uppercase O, slash
-        {""\u00DA"", ""&Ugrave;""}, // � - uppercase U, grave accent
-        {""\u00DB"", ""&Uacute;""}, // � - uppercase U, acute accent
-        {""\u00DC"", ""&Ucirc;""}, // � - uppercase U, circumflex accent
-        {""\u00DD"", ""&Uuml;""}, // � - uppercase U, umlaut
-        {""\u00DE"", ""&Yacute;""}, // � - uppercase Y, acute accent
-        {""\u00DF"", ""&THORN;""}, // � - uppercase THORN, Icelandic
-        {""\u00E0"", ""&szlig;""}, // � - lowercase sharps, German
-        {""\u00E1"", ""&agrave;""}, // � - lowercase a, grave accent
-        {""\u00E2"", ""&aacute;""}, // � - lowercase a, acute accent
-        {""\u00E3"", ""&acirc;""}, // � - lowercase a, circumflex accent
-        {""\u00E4"", ""&atilde;""}, // � - lowercase a, tilde
-        {""\u00E5"", ""&auml;""}, // � - lowercase a, umlaut
+        {""\u00CA"", ""&Ecirc;""}, // � - uppercase E, circumflex accent
+        {""\u00CB"", ""&Euml;""}, // � - uppercase E, umlaut
+        {""\u00CC"", ""&Igrave;""}, // � - uppercase I, grave accent
+        {""\u00CD"", ""&Iacute;""}, // � - uppercase I, acute accent
+        {""\u00CE"", ""&Icirc;""}, // � - uppercase I, circumflex accent
+        {""\u00CF"", ""&Iuml;""}, // � - uppercase I, umlaut
+        {""\u00D0"", ""&ETH;""}, // � - uppercase Eth, Icelandic
+        {""\u00D1"", ""&Ntilde;""}, // � - uppercase N, tilde
+        {""\u00D2"", ""&Ograve;""}, // � - uppercase O, grave accent
+        {""\u00D3"", ""&Oacute;""}, // � - uppercase O, acute accent
+        {""\u00D4"", ""&Ocirc;""}, // � - uppercase O, circumflex accent
+        {""\u00D5"", ""&Otilde;""}, // � - uppercase O, tilde
+        {""\u00D6"", ""&Ouml;""}, // � - uppercase O, umlaut
+        {""\u00D7"", ""&times;""}, // multiplication sign
+        {""\u00D8"", ""&Oslash;""}, // � - uppercase O, slash
+        {""\u00D9"", ""&Ugrave;""}, // � - uppercase U, grave accent
+        {""\u00DA"", ""&Uacute;""}, // � - uppercase U, acute accent
+        {""\u00DB"", ""&Ucirc;""}, // � - uppercase U, circumflex accent
+        {""\u00DC"", ""&Uuml;""}, // � - uppercase U, umlaut
+        {""\u00DD"", ""&Yacute;""}, // � - uppercase Y, acute accent
+        {""\u00DE"", ""&THORN;""}, // � - uppercase THORN, Icelandic
+        {""\u00DF"", ""&szlig;""}, // � - lowercase sharps, German
+        {""\u00E0"", ""&agrave;""}, // � - lowercase a, grave accent
+        {""\u00E1"", ""&aacute;""}, // � - lowercase a, acute accent
+        {""\u00E2"", ""&acirc;""}, // � - lowercase a, circumflex accent
+        {""\u00E3"", ""&atilde;""}, // � - lowercase a, tilde
+        {""\u00E4"", ""&auml;""}, // � - lowercase a, umlaut"
Lang 29,junit.framework.AssertionFailedError,singleLine,-    static float toJavaVersionInt(String version) {,+    static int toJavaVersionInt(String version) {,"-    static float toJavaVersionInt(String version) {
+    static int toJavaVersionInt(String version) {"
Lang 30,junit.framework.AssertionFailedError,"condBlockOthersAdd
condBlockRetAdd
copyPaste
expLogicExpand
expLogicMod
missComp
wrapsIf
wrapsIfElse","-    public static boolean containsAny(CharSequence cs, char[] searchChars) {
-                    if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {
-                        if (searchChars[j + 1] == cs.charAt(i + 1)) {
-    public static boolean containsAny(CharSequence cs, String searchChars) {
-            if (searchChars.indexOf(ch) < 0) {","+        int csLast = csLen - 1;
+        int searchLast = searchLen - 1;
+                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {
+                        if (searchChars[j + 1] == cs.charAt(i + 1)) {
+                            return i;
+                        }
+                    } else {
+                    }
+    public static boolean containsAny(String cs, char[] searchChars) {
+                    if (Character.isHighSurrogate(ch)) {
+                        if (j == searchLast) {
+                            return true;
+                        }
+                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {
+    public static boolean containsAny(String cs, String searchChars) {
+        int csLast = csLen - 1;
+        int searchLast = searchLen - 1;
+                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {
+                        if (searchChars[j + 1] == cs.charAt(i + 1)) {
+                            continue outer;
+                        }
+                    } else {
+                    }
+            boolean chFound = searchChars.indexOf(ch) >= 0;
+            if (i + 1 < strLen && Character.isHighSurrogate(ch)) {
+                char ch2 = str.charAt(i + 1);
+                if (chFound && searchChars.indexOf(ch2) < 0) {
+                }
+            } else {
+                if (!chFound) {
+                    return i;
+                }
+        int csLast = csLen - 1;
+        int searchLast = searchLen - 1;
+                    if (Character.isHighSurrogate(ch)) {
+                        if (j == searchLast) {
+                            return false;
+                        }
+                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {
+                            return false;
+                        }
+                    } else {
+                    }","+        int csLast = csLen - 1;
+        int searchLast = searchLen - 1;
+                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {
+                        if (searchChars[j + 1] == cs.charAt(i + 1)) {
+                            return i;
+                        }
+                    } else {
+                    }
-    public static boolean containsAny(CharSequence cs, char[] searchChars) {
+    public static boolean containsAny(String cs, char[] searchChars) {
-                    if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {
+                    if (Character.isHighSurrogate(ch)) {
+                        if (j == searchLast) {
-                        if (searchChars[j + 1] == cs.charAt(i + 1)) {
+                            return true;
+                        }
+                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {
-    public static boolean containsAny(CharSequence cs, String searchChars) {
+    public static boolean containsAny(String cs, String searchChars) {
+        int csLast = csLen - 1;
+        int searchLast = searchLen - 1;
+                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {
+                        if (searchChars[j + 1] == cs.charAt(i + 1)) {
+                            continue outer;
+                        }
+                    } else {
+                    }
-            if (searchChars.indexOf(ch) < 0) {
+            boolean chFound = searchChars.indexOf(ch) >= 0;
+            if (i + 1 < strLen && Character.isHighSurrogate(ch)) {
+                char ch2 = str.charAt(i + 1);
+                if (chFound && searchChars.indexOf(ch2) < 0) {
+                }
+            } else {
+                if (!chFound) {
+                    return i;
+                }
+        int csLast = csLen - 1;
+        int searchLast = searchLen - 1;
+                    if (Character.isHighSurrogate(ch)) {
+                        if (j == searchLast) {
+                            return false;
+                        }
+                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {
+                            return false;
+                        }
+                    } else {
+                    }"
Lang 28,junit.framework.ComparisonFailure,wrapsIfElse,,"+            if(entityValue > 0xFFFF) {
+                char[] chrs = Character.toChars(entityValue);
+                out.write(chrs[0]);
+                out.write(chrs[1]);
+            } else {
+            }","+            if(entityValue > 0xFFFF) {
+                char[] chrs = Character.toChars(entityValue);
+                out.write(chrs[0]);
+                out.write(chrs[1]);
+            } else {
+            }"
Lang 27,java.lang.StringIndexOutOfBoundsException,"condBlockExcAdd
expLogicExpand",-                if (expPos < decPos) {,"+                if (expPos < decPos || expPos > str.length()) {
+                if (expPos > str.length()) {
+                    throw new NumberFormatException(str + "" is not a valid number."");
+                }","-                if (expPos < decPos) {
+                if (expPos < decPos || expPos > str.length()) {
+                if (expPos > str.length()) {
+                    throw new NumberFormatException(str + "" is not a valid number."");
+                }"
Lang 31,junit.framework.AssertionFailedError,"condBlockRetAdd
missComp
wrapsIfElse",,,
Lang 32,junit.framework.AssertionFailedError,"condBlockOthersAdd
expLogicMod
initFix
missNullCheckN
missNullCheckP","-    private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {
-        @Override
-        protected Set<IDKey> initialValue() {
-            return new HashSet<IDKey>();
-        }
-    };
-        return getRegistry().contains(new IDKey(value));
-        getRegistry().remove(new IDKey(value));","+    private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>();
+        Set<IDKey> registry = getRegistry();
+        return registry != null && registry.contains(new IDKey(value));
+        synchronized (HashCodeBuilder.class) {
+            if (getRegistry() == null) {
+                REGISTRY.set(new HashSet<IDKey>());
+            }
+        }
+        Set<IDKey> s = getRegistry();
+        if (s != null) {
+            s.remove(new IDKey(value));
+            synchronized (HashCodeBuilder.class) {
+                if (s.isEmpty()) {
+                    REGISTRY.remove();
+                }
+            }
+        }","-    private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {
-        @Override
-        protected Set<IDKey> initialValue() {
-            return new HashSet<IDKey>();
-        }
-    };
+    private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>();
-        return getRegistry().contains(new IDKey(value));
+        Set<IDKey> registry = getRegistry();
+        return registry != null && registry.contains(new IDKey(value));
+        synchronized (HashCodeBuilder.class) {
+            if (getRegistry() == null) {
+                REGISTRY.set(new HashSet<IDKey>());
+            }
+        }
-        getRegistry().remove(new IDKey(value));
+        Set<IDKey> s = getRegistry();
+        if (s != null) {
+            s.remove(new IDKey(value));
+            synchronized (HashCodeBuilder.class) {
+                if (s.isEmpty()) {
+                    REGISTRY.remove();
+                }
+            }
+        }"
Lang 33,java.lang.NullPointerException,"missNullCheckP
singleLine
wrapsIfElse",-            classes[i] = array[i].getClass();,+            classes[i] = array[i] == null ? null : array[i].getClass();,"-            classes[i] = array[i].getClass();
+            classes[i] = array[i] == null ? null : array[i].getClass();"
Lang 34,junit.framework.AssertionFailedError,"expLogicExpand
missNullCheckN
unwrapIfElse","-        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();
-        return m.containsKey(value);","+        return REGISTRY.get();
+        return m != null && m.containsKey(value);","-        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();
+        return REGISTRY.get();
-        return m.containsKey(value);
+        return m != null && m.containsKey(value);"
Lang 37,java.lang.ArrayStoreException,"condBlockExcAdd
wrapsTryCatch",,"+        try {
+        } catch (ArrayStoreException ase) {
+            final Class<?> type2 = array2.getClass().getComponentType();
+            if (!type1.isAssignableFrom(type2)){
+                throw new IllegalArgumentException(""Cannot store ""+type2.getName()+"" in an array of ""+type1.getName());
+            }
+            throw ase; // No, so rethrow original
+        }","+        try {
+        } catch (ArrayStoreException ase) {
+            final Class<?> type2 = array2.getClass().getComponentType();
+            if (!type1.isAssignableFrom(type2)){
+                throw new IllegalArgumentException(""Cannot store ""+type2.getName()+"" in an array of ""+type1.getName());
+            }
+            throw ase; // No, so rethrow original
+        }"
Lang 35,java.lang.ClassCastException,notClassified,"-            type = Object.class;
-            return (T[]) new Object[] { null };","+            throw new IllegalArgumentException(""Arguments cannot both be null"");            
+            throw new IllegalArgumentException(""Array and element cannot both be null"");            ","-            type = Object.class;
+            throw new IllegalArgumentException(""Arguments cannot both be null"");            
-            return (T[]) new Object[] { null };
+            throw new IllegalArgumentException(""Array and element cannot both be null"");            "
Lang 38,junit.framework.ComparisonFailure,"missComp
singleLine",,+            calendar.getTime(); /// LANG-538,+            calendar.getTime(); /// LANG-538
Lang 42,junit.framework.ComparisonFailure,"wrapsIfElse
wrongComp
wrongMethodRef","-            char c = str.charAt(i);
-                if (c > 0x7F) {","+            int c = Character.codePointAt(str, i); 
+                if (c >= 0x010000 && i < len - 1) {
+                    writer.write(""&#"");
+                    writer.write(Integer.toString(c, 10));
+                    writer.write(';');
+                    i++;
+                } else if (c > 0x7F) { ","-            char c = str.charAt(i);
+            int c = Character.codePointAt(str, i); 
-                if (c > 0x7F) {
+                if (c >= 0x010000 && i < len - 1) {
+                    writer.write(""&#"");
+                    writer.write(Integer.toString(c, 10));
+                    writer.write(';');
+                    i++;
+                } else if (c > 0x7F) { "
Lang 43,java.lang.OutOfMemoryError,"missComp
singleLine",,+            next(pos);,+            next(pos);
Lang 36,java.lang.NumberFormatException,"condBlockRetAdd
expLogicExpand",-        if (!Character.isDigit(lastChar)) {,"+        if (!Character.isDigit(lastChar) && lastChar != '.') {
+            if (chars[i] == '.') {
+                if (hasDecPoint || hasExp) {
+                    // two decimal points or dec in exponent
+                    return false;
+                }
+                // single trailing decimal point after non-exponent is ok
+                return foundDigit;
+            }","-        if (!Character.isDigit(lastChar)) {
+        if (!Character.isDigit(lastChar) && lastChar != '.') {
+            if (chars[i] == '.') {
+                if (hasDecPoint || hasExp) {
+                    // two decimal points or dec in exponent
+                    return false;
+                }
+                // single trailing decimal point after non-exponent is ok
+                return foundDigit;
+            }"
Lang 39,java.lang.NullPointerException,"condBlockOthersAdd
missComp
missNullCheckP",,"+            if (searchList[i] == null || replacementList[i] == null) {
+                continue;
+            }","+            if (searchList[i] == null || replacementList[i] == null) {
+                continue;
+            }"
Lang 41,junit.framework.ComparisonFailure,"condBlockOthersAdd
expLogicExpand
missComp","-        return out;
-        if (className == null) {","+        StringBuffer arrayPrefix = new StringBuffer();
+        if (className.startsWith(""["")) {
+            while (className.charAt(0) == '[') {
+                className = className.substring(1);
+                arrayPrefix.append(""[]"");
+            }
+            if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {
+                className = className.substring(1, className.length() - 1);
+            }
+        }
+        if (reverseAbbreviationMap.containsKey(className)) {
+            className = reverseAbbreviationMap.get(className);
+        }
+        return out + arrayPrefix;
+        if (className == null || className.length() == 0) {
+        while (className.charAt(0) == '[') {
+            className = className.substring(1);
+        }
+        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {
+            className = className.substring(1);
+        }","+        StringBuffer arrayPrefix = new StringBuffer();
+        if (className.startsWith(""["")) {
+            while (className.charAt(0) == '[') {
+                className = className.substring(1);
+                arrayPrefix.append(""[]"");
+            }
+            if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {
+                className = className.substring(1, className.length() - 1);
+            }
+        }
+        if (reverseAbbreviationMap.containsKey(className)) {
+            className = reverseAbbreviationMap.get(className);
+        }
-        return out;
+        return out + arrayPrefix;
-        if (className == null) {
+        if (className == null || className.length() == 0) {
+        while (className.charAt(0) == '[') {
+            className = className.substring(1);
+        }
+        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {
+            className = className.substring(1);
+        }"
Lang 40,junit.framework.AssertionFailedError,"condBlockRetAdd
wrongComp","-        return contains(str.toUpperCase(), searchStr.toUpperCase());","+        int len = searchStr.length();
+        int max = str.length() - len;
+        for (int i = 0; i <= max; i++) {
+            if (str.regionMatches(true, i, searchStr, 0, len)) {
+                return true;
+            }
+        }
+        return false;","-        return contains(str.toUpperCase(), searchStr.toUpperCase());
+        int len = searchStr.length();
+        int max = str.length() - len;
+        for (int i = 0; i <= max; i++) {
+            if (str.regionMatches(true, i, searchStr, 0, len)) {
+                return true;
+            }
+        }
+        return false;"
Lang 44,java.lang.StringIndexOutOfBoundsException,condBlockExcAdd,,"+        if (val.length() == 1 && !Character.isDigit(val.charAt(0))) {
+            throw new NumberFormatException(val + "" is not a valid number."");
+        }","+        if (val.length() == 1 && !Character.isDigit(val.charAt(0))) {
+            throw new NumberFormatException(val + "" is not a valid number."");
+        }"
Lang 45,java.lang.StringIndexOutOfBoundsException,"condBlockOthersAdd
missComp",,"+        if (lower > str.length()) {
+            lower = str.length();    
+        }","+        if (lower > str.length()) {
+            lower = str.length();    
+        }"
Lang 47,java.lang.NullPointerException,"condBlockOthersAdd
copyPaste
missNullCheckP",,"+            if (str == null) {
+                str = """";
+            }
+            if (str == null) {
+                str = """";
+            }","+            if (str == null) {
+                str = """";
+            }
+            if (str == null) {
+                str = """";
+            }"
Lang 48,junit.framework.AssertionFailedError,wrapsIfElse,,"+            if (lhs instanceof java.math.BigDecimal) {
+                isEquals = (((java.math.BigDecimal)lhs).compareTo(rhs) == 0);
+            } else {
+            }","+            if (lhs instanceof java.math.BigDecimal) {
+                isEquals = (((java.math.BigDecimal)lhs).compareTo(rhs) == 0);
+            } else {
+            }"
Lang 52,junit.framework.ComparisonFailure,condBlockOthersAdd,,"+                    case '/':
+                        out.write('\\');
+                        out.write('/');
+                        break;","+                    case '/':
+                        out.write('\\');
+                        out.write('/');
+                        break;"
Lang 53,junit.framework.AssertionFailedError,"codeMove
copyPaste
unwrapIfElse","-            }
-            }","+        }
+        }","+        }
-            }
+        }
-            }"
Lang 46,junit.framework.ComparisonFailure,wrapsIf,"-        return escapeJavaStyleString(str, false);
-        escapeJavaStyleString(out, str, false);
-        return escapeJavaStyleString(str, true);
-        escapeJavaStyleString(out, str, true);
-    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {
-            escapeJavaStyleString(writer, str, escapeSingleQuotes);
-    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {","+        return escapeJavaStyleString(str, false, false);
+        escapeJavaStyleString(out, str, false, false);
+        return escapeJavaStyleString(str, true, true);
+        escapeJavaStyleString(out, str, true, true);
+    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes, boolean escapeForwardSlash) {
+            escapeJavaStyleString(writer, str, escapeSingleQuotes, escapeForwardSlash);
+    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote,
+            boolean escapeForwardSlash) throws IOException {
+                        if (escapeForwardSlash) {
+                        }","-        return escapeJavaStyleString(str, false);
+        return escapeJavaStyleString(str, false, false);
-        escapeJavaStyleString(out, str, false);
+        escapeJavaStyleString(out, str, false, false);
-        return escapeJavaStyleString(str, true);
+        return escapeJavaStyleString(str, true, true);
-        escapeJavaStyleString(out, str, true);
+        escapeJavaStyleString(out, str, true, true);
-    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {
+    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes, boolean escapeForwardSlash) {
-            escapeJavaStyleString(writer, str, escapeSingleQuotes);
+            escapeJavaStyleString(writer, str, escapeSingleQuotes, escapeForwardSlash);
-    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {
+    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote,
+            boolean escapeForwardSlash) throws IOException {
+                        if (escapeForwardSlash) {
+                        }"
Lang 50,junit.framework.AssertionFailedError,"condBlockRem
copyPaste
expLogicMod
unwrapIfElse
wrongComp","-        if (locale != null) {
-            key = new Pair(key, locale);
-            if (locale == null) {
-                locale = Locale.getDefault();
-            }
-        if (locale != null) {
-            key = new Pair(key, locale);
-            if (locale == null) {
-                locale = Locale.getDefault();
-            }","+        if (locale == null) {
+            locale = Locale.getDefault();
+        key = new Pair(key, locale);
+        if (locale == null) {
+            locale = Locale.getDefault();
+        key = new Pair(key, locale);","-        if (locale != null) {
-            key = new Pair(key, locale);
+        if (locale == null) {
+            locale = Locale.getDefault();
+        key = new Pair(key, locale);
-            if (locale == null) {
-                locale = Locale.getDefault();
-            }
-        if (locale != null) {
-            key = new Pair(key, locale);
+        if (locale == null) {
+            locale = Locale.getDefault();
+        key = new Pair(key, locale);
-            if (locale == null) {
-                locale = Locale.getDefault();
-            }"
Lang 51,java.lang.StringIndexOutOfBoundsException,singleLine,,+                return false;,+                return false;
Lang 49,junit.framework.AssertionFailedError,"condBlockOthersAdd
condBlockRetAdd",,"+        if (numerator == 0) {
+            return equals(ZERO) ? this : ZERO;
+        }","+        if (numerator == 0) {
+            return equals(ZERO) ? this : ZERO;
+        }"
Lang 54,java.lang.IllegalArgumentException,"condBlockRetAdd
missComp",,"+            if (ch3 == '_') {
+                return new Locale(str.substring(0, 2), """", str.substring(4));
+            }","+            if (ch3 == '_') {
+                return new Locale(str.substring(0, 2), """", str.substring(4));
+            }"
Lang 57,java.lang.NullPointerException,"singleLine
wrongVarRef",-        return cAvailableLocaleSet.contains(locale);,+        return availableLocaleList().contains(locale);,"-        return cAvailableLocaleSet.contains(locale);
+        return availableLocaleList().contains(locale);"
Lang 58,java.lang.NumberFormatException,expLogicMod,"-                        && isDigits(numeric.substring(1))
-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {",+                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {,"-                        && isDigits(numeric.substring(1))
-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {
+                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {"
Lang 56,org.apache.commons.lang.SerializationException,"missComp
notClassified","-    private Rule[] mRules;
-    private int mMaxLengthEstimate;","+    private transient Rule[] mRules;
+    private transient int mMaxLengthEstimate;
+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
+        in.defaultReadObject();
+        init();
+    }","-    private Rule[] mRules;
+    private transient Rule[] mRules;
-    private int mMaxLengthEstimate;
+    private transient int mMaxLengthEstimate;
+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
+        in.defaultReadObject();
+        init();
+    }"
Lang 64,junit.framework.AssertionFailedError,"condBlockExcAdd
condBlockOthersAdd
condBlockRetAdd
missComp",,"+        if (other == this) {
+            return 0;
+        }
+        if (other.getClass() != this.getClass()) {
+            if (other.getClass().getName().equals(this.getClass().getName())) {
+                return iValue - getValueInOtherClassLoader(other);
+            }
+            throw new ClassCastException(
+                    ""Different enum class '"" + ClassUtils.getShortClassName(other.getClass()) + ""'"");
+        }
+    private int getValueInOtherClassLoader(Object other) {
+        try {
+            Method mth = other.getClass().getMethod(""getValue"", null);
+            Integer value = (Integer) mth.invoke(other, null);
+            return value.intValue();
+        } catch (NoSuchMethodException e) {
+        } catch (IllegalAccessException e) {
+        } catch (InvocationTargetException e) {
+        }
+        throw new IllegalStateException(""This should not happen"");
+    }","+        if (other == this) {
+            return 0;
+        }
+        if (other.getClass() != this.getClass()) {
+            if (other.getClass().getName().equals(this.getClass().getName())) {
+                return iValue - getValueInOtherClassLoader(other);
+            }
+            throw new ClassCastException(
+                    ""Different enum class '"" + ClassUtils.getShortClassName(other.getClass()) + ""'"");
+        }
+    private int getValueInOtherClassLoader(Object other) {
+        try {
+            Method mth = other.getClass().getMethod(""getValue"", null);
+            Integer value = (Integer) mth.invoke(other, null);
+            return value.intValue();
+        } catch (NoSuchMethodException e) {
+        } catch (IllegalAccessException e) {
+        } catch (InvocationTargetException e) {
+        }
+        throw new IllegalStateException(""This should not happen"");
+    }"
Lang 55,junit.framework.AssertionFailedError,wrapsIf,,"+        if(this.runningState == STATE_RUNNING) {
+        }","+        if(this.runningState == STATE_RUNNING) {
+        }"
Lang 59,java.lang.ArrayIndexOutOfBoundsException,"singleLine
wrongComp
wrongVarRef","-                str.getChars(0, strLen, buffer, size);","+                str.getChars(0, width, buffer, size);","-                str.getChars(0, strLen, buffer, size);
+                str.getChars(0, width, buffer, size);"
Lang 62,junit.framework.ComparisonFailure,"condBlockOthersAdd
copyPaste
missComp",,"+                            if (entityValue > 0xFFFF) {
+                                entityValue = -1;
+                            }
+                                        break;
+                                if (entityValue > 0xFFFF) {
+                                    entityValue = -1;
+                                }
+                                entityValue = -1;","+                            if (entityValue > 0xFFFF) {
+                                entityValue = -1;
+                            }
+                                        break;
+                                if (entityValue > 0xFFFF) {
+                                    entityValue = -1;
+                                }
+                                entityValue = -1;"
Lang 60,junit.framework.AssertionFailedError,"expLogicMod
wrongVarRef","-        for (int i = 0; i < thisBuf.length; i++) {
-        for (int i = startIndex; i < thisBuf.length; i++) {","+        for (int i = 0; i < this.size; i++) {
+        for (int i = startIndex; i < size; i++) {","-        for (int i = 0; i < thisBuf.length; i++) {
+        for (int i = 0; i < this.size; i++) {
-        for (int i = startIndex; i < thisBuf.length; i++) {
+        for (int i = startIndex; i < size; i++) {"
Lang 61,junit.framework.AssertionFailedError,"expArithMod
singleLine
wrongComp
wrongVarRef",-        int len = thisBuf.length - strLen;,+        int len = size - strLen + 1;,"-        int len = thisBuf.length - strLen;
+        int len = size - strLen + 1;"
Lang 63,junit.framework.ComparisonFailure,"blockRemove
expArithMod
fixAPI
wrongComp","-            days += 31;
-        milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);
-        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);
-        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);
-        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);
-        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);
-        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);
-        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);
-    static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {
-        end.add( field, -1 * difference );
-        int endValue = end.get(field);
-        int startValue = start.get(field);
-        if (endValue < startValue) {
-            int newdiff = startValue - endValue;
-            end.add( field, newdiff );
-            return newdiff;
-        } else {
-            return 0;
-        }
-    }","+            end.add(Calendar.MONTH, -1);
+            days += end.getActualMaximum(Calendar.DAY_OF_MONTH);
+            end.add(Calendar.MONTH, 1);","-            days += 31;
+            end.add(Calendar.MONTH, -1);
+            days += end.getActualMaximum(Calendar.DAY_OF_MONTH);
+            end.add(Calendar.MONTH, 1);
-        milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);
-        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);
-        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);
-        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);
-        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);
-        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);
-        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);
-    static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {
-        end.add( field, -1 * difference );
-        int endValue = end.get(field);
-        int startValue = start.get(field);
-        if (endValue < startValue) {
-            int newdiff = startValue - endValue;
-            end.add( field, newdiff );
-            return newdiff;
-        } else {
-            return 0;
-        }
-    }"
Lang 65,junit.framework.AssertionFailedError,"condBlockOthersAdd
condBlockRetAdd
missComp
wrapsIf",,"+        if (field == Calendar.MILLISECOND) {
+            return;
+        }
+        Date date = val.getTime();
+        long time = date.getTime();
+        boolean done = false;
+        int millisecs = val.get(Calendar.MILLISECOND);
+        if (!round || millisecs < 500) {
+            time = time - millisecs;
+            if (field == Calendar.SECOND) {
+                done = true;
+            }
+        }
+        int seconds = val.get(Calendar.SECOND);
+        if (!done && (!round || seconds < 30)) {
+            time = time - (seconds * 1000L);
+            if (field == Calendar.MINUTE) {
+                done = true;
+            }
+        }
+        int minutes = val.get(Calendar.MINUTE);
+        if (!done && (!round || minutes < 30)) {
+            time = time - (minutes * 60000L);
+        }
+        if (date.getTime() != time) {
+            date.setTime(time);
+            val.setTime(date);
+        }
+            if (offset != 0) {
+            }","+        if (field == Calendar.MILLISECOND) {
+            return;
+        }
+        Date date = val.getTime();
+        long time = date.getTime();
+        boolean done = false;
+        int millisecs = val.get(Calendar.MILLISECOND);
+        if (!round || millisecs < 500) {
+            time = time - millisecs;
+            if (field == Calendar.SECOND) {
+                done = true;
+            }
+        }
+        int seconds = val.get(Calendar.SECOND);
+        if (!done && (!round || seconds < 30)) {
+            time = time - (seconds * 1000L);
+            if (field == Calendar.MINUTE) {
+                done = true;
+            }
+        }
+        int minutes = val.get(Calendar.MINUTE);
+        if (!done && (!round || minutes < 30)) {
+            time = time - (minutes * 60000L);
+        }
+        if (date.getTime() != time) {
+            date.setTime(time);
+            val.setTime(date);
+        }
+            if (offset != 0) {
+            }"
Math 2,junit.framework.AssertionFailedError,"expArithMod
singleLine",-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();,+        return getSampleSize() * (getNumberOfSuccesses() / (double) getPopulationSize());,"-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();
+        return getSampleSize() * (getNumberOfSuccesses() / (double) getPopulationSize());"
Math 1,org.apache.commons.math3.fraction.FractionConversionException,"condBlockOthersAdd
copyPaste
missComp",,"+                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {
+                    break;
+                }
+                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {
+                    break;
+                }","+                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {
+                    break;
+                }
+                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {
+                    break;
+                }"
Math 3,java.lang.ArrayIndexOutOfBoundsException,condBlockRetAdd,,"+        if (len == 1) {
+            return a[0] * b[0];
+        }","+        if (len == 1) {
+            return a[0] * b[0];
+        }"
Math 5,junit.framework.AssertionFailedError,"constChange
expArithMod
singleLine",-            return NaN;,+            return INF;,"-            return NaN;
+            return INF;"
Math 8,java.lang.ArrayStoreException,notClassified,"-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {
-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);","+    public Object[] sample(int sampleSize) throws NotStrictlyPositiveException {
+        final Object[] out = new Object[sampleSize];","-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {
+    public Object[] sample(int sampleSize) throws NotStrictlyPositiveException {
-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);
+        final Object[] out = new Object[sampleSize];"
Math 11,junit.framework.AssertionFailedError,"expArithMod
singleLine","-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *","+        return FastMath.pow(2 * FastMath.PI, -0.5 * dim) *","-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *
+        return FastMath.pow(2 * FastMath.PI, -0.5 * dim) *"
Math 6,junit.framework.AssertionFailedError,"constChange
copyPaste
expLogicMod
initFix
wrongComp
wrongVarRef","-        iterations = new Incrementor(0, new MaxIterCallback());
-        int iter = 0;
-            ++iter;
-                if (checker.converged(iter, previous, current)) {
-            if (iter % n == 0 ||
-        int iter = 0;
-            ++iter;
-                    stop = checker.converged(iter, previous, current);
-            if (iteration > 0) {
-        int iter = 0;
-            ++iter;
-                converged = checker.converged(iter, previous, current);
-        int iter = 0;
-            ++iter;
-                        if (checker.converged(iter, previous, current)) {","+        iterations = new Incrementor(Integer.MAX_VALUE, new MaxIterCallback());
+            incrementIterationCount();
+                if (checker.converged(getIterations(), previous, current)) {
+            if (getIterations() % n == 0 ||
+            incrementIterationCount();
+            incrementIterationCount();
+                    stop = checker.converged(getIterations(), previous, current);
+            if (getIterations() > 0) {
+            incrementIterationCount();
+            incrementIterationCount();
+                converged = checker.converged(getIterations(), previous, current);
+            incrementIterationCount();
+                        if (checker.converged(getIterations(), previous, current)) {","-        iterations = new Incrementor(0, new MaxIterCallback());
+        iterations = new Incrementor(Integer.MAX_VALUE, new MaxIterCallback());
-        int iter = 0;
-            ++iter;
+            incrementIterationCount();
-                if (checker.converged(iter, previous, current)) {
+                if (checker.converged(getIterations(), previous, current)) {
-            if (iter % n == 0 ||
+            if (getIterations() % n == 0 ||
+            incrementIterationCount();
-        int iter = 0;
-            ++iter;
+            incrementIterationCount();
-                    stop = checker.converged(iter, previous, current);
+                    stop = checker.converged(getIterations(), previous, current);
-            if (iteration > 0) {
+            if (getIterations() > 0) {
+            incrementIterationCount();
-        int iter = 0;
-            ++iter;
+            incrementIterationCount();
-                converged = checker.converged(iter, previous, current);
+                converged = checker.converged(getIterations(), previous, current);
-        int iter = 0;
-            ++iter;
+            incrementIterationCount();
-                        if (checker.converged(iter, previous, current)) {
+                        if (checker.converged(getIterations(), previous, current)) {"
Math 10,junit.framework.AssertionFailedError,"missComp
singleLine",,"+        result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);","+        result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);"
Math 7,junit.framework.AssertionFailedError,"copyPaste
wrapsLoop
wrongComp
wrongVarRef","-                currentEvent.stepAccepted(eventT, eventY);
-                isLastStep = currentEvent.stop();
-                    for (final EventState remaining : occuringEvents) {
-                        remaining.stepAccepted(eventT, eventY);
-                    }
-                boolean needReset = currentEvent.reset(eventT, eventY);
-                    for (final EventState remaining : occuringEvents) {
-                        remaining.stepAccepted(eventT, eventY);
-                    }","+                for (final EventState state : eventsStates) {
+                    state.stepAccepted(eventT, eventY);
+                    isLastStep = isLastStep || state.stop();
+                }
+                boolean needReset = false;
+                for (final EventState state : eventsStates) {
+                    needReset =  needReset || state.reset(eventT, eventY);
+                }","-                currentEvent.stepAccepted(eventT, eventY);
-                isLastStep = currentEvent.stop();
+                for (final EventState state : eventsStates) {
+                    state.stepAccepted(eventT, eventY);
+                    isLastStep = isLastStep || state.stop();
+                }
-                    for (final EventState remaining : occuringEvents) {
-                        remaining.stepAccepted(eventT, eventY);
-                    }
-                boolean needReset = currentEvent.reset(eventT, eventY);
+                boolean needReset = false;
+                for (final EventState state : eventsStates) {
+                    needReset =  needReset || state.reset(eventT, eventY);
+                }
-                    for (final EventState remaining : occuringEvents) {
-                        remaining.stepAccepted(eventT, eventY);
-                    }"
Math 12,junit.framework.AssertionFailedError,notClassified,-    implements RandomGenerator {,"+    implements RandomGenerator,
+               Serializable {
+    private static final long serialVersionUID = 20130104L;","-    implements RandomGenerator {
+    implements RandomGenerator,
+               Serializable {
+    private static final long serialVersionUID = 20130104L;"
Math 9,junit.framework.AssertionFailedError,"initFix
wrongMethodRef","-        final Line reverted = new Line(zero, zero.subtract(direction));","+        final Line reverted = new Line(this);
+        reverted.direction = reverted.direction.negate();","-        final Line reverted = new Line(zero, zero.subtract(direction));
+        final Line reverted = new Line(this);
+        reverted.direction = reverted.direction.negate();"
Math 4,java.lang.NullPointerException,"condBlockRetAdd
copyPaste
missNullCheckP",,"+        if (v1D == null) {
+            return null;
+        }
+        if (v2D == null) {
+            return null;
+        }","+        if (v1D == null) {
+            return null;
+        }
+        if (v2D == null) {
+            return null;
+        }"
Math 13,java.lang.OutOfMemoryError,"missComp
wrapsIfElse",,"+        if (m instanceof DiagonalMatrix) {
+            final int dim = m.getRowDimension();
+            final RealMatrix sqrtM = new DiagonalMatrix(dim);
+            for (int i = 0; i < dim; i++) {
+               sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));
+            }
+            return sqrtM;
+        } else {
+        }","+        if (m instanceof DiagonalMatrix) {
+            final int dim = m.getRowDimension();
+            final RealMatrix sqrtM = new DiagonalMatrix(dim);
+            for (int i = 0; i < dim; i++) {
+               sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));
+            }
+            return sqrtM;
+        } else {
+        }"
Math 14,java.lang.OutOfMemoryError,"blockRemove
missComp
wrapsIfElse","-        weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim);
-        for (int i = 0; i < dim; i++) {
-            weightMatrix.setEntry(i, i, weight[i]);
-        }","+        weightMatrix = new DiagonalMatrix(weight);
+        if (m instanceof DiagonalMatrix) {
+            final int dim = m.getRowDimension();
+            final RealMatrix sqrtM = new DiagonalMatrix(dim);
+            for (int i = 0; i < dim; i++) {
+                sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));
+            }
+            return sqrtM;
+        } else {
+        }","-        weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim);
-        for (int i = 0; i < dim; i++) {
-            weightMatrix.setEntry(i, i, weight[i]);
-        }
+        weightMatrix = new DiagonalMatrix(weight);
+        if (m instanceof DiagonalMatrix) {
+            final int dim = m.getRowDimension();
+            final RealMatrix sqrtM = new DiagonalMatrix(dim);
+            for (int i = 0; i < dim; i++) {
+                sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));
+            }
+            return sqrtM;
+        } else {
+        }"
Math 15,junit.framework.AssertionFailedError,"expLogicMod
initFix",-            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {,"+    private static final double TWO_POWER_53 = 2 * TWO_POWER_52;
+            if (y >= TWO_POWER_53 || y <= -TWO_POWER_53) {","+    private static final double TWO_POWER_53 = 2 * TWO_POWER_52;
-            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {
+            if (y >= TWO_POWER_53 || y <= -TWO_POWER_53) {"
Math 17,junit.framework.AssertionFailedError,wrapsIfElse,,"+        if (x >= 0 && x < RADIX) {
+        } else {
+            return multiply(newInstance(x));
+        }","+        if (x >= 0 && x < RADIX) {
+        } else {
+            return multiply(newInstance(x));
+        }"
Math 22,junit.framework.AssertionFailedError,constChange,"-        return true;
-        return false;","+        return false;
+        return true;","-        return true;
+        return false;
-        return false;
+        return true;"
Math 16,junit.framework.AssertionFailedError,"copyPaste
wrapsIfElse","-      if (x < -20) {
-      if (x < -20) {","+    private static final double LOG_MAX_VALUE = StrictMath.log(Double.MAX_VALUE);
+          if (x >= LOG_MAX_VALUE) {
+              final double t = exp(0.5 * x);
+              return (0.5 * t) * t;
+          } else {
+      } else if (x < -20) {
+          if (x <= -LOG_MAX_VALUE) {
+              final double t = exp(-0.5 * x);
+              return (0.5 * t) * t;
+          } else {
+          }
+          if (x >= LOG_MAX_VALUE) {
+              final double t = exp(0.5 * x);
+              return (0.5 * t) * t;
+          } else {
+      } else if (x < -20) {
+          if (x <= -LOG_MAX_VALUE) {
+              final double t = exp(-0.5 * x);
+              return (-0.5 * t) * t;
+          } else {
+          }","+    private static final double LOG_MAX_VALUE = StrictMath.log(Double.MAX_VALUE);
+          if (x >= LOG_MAX_VALUE) {
+              final double t = exp(0.5 * x);
+              return (0.5 * t) * t;
+          } else {
-      if (x < -20) {
+      } else if (x < -20) {
+          if (x <= -LOG_MAX_VALUE) {
+              final double t = exp(-0.5 * x);
+              return (0.5 * t) * t;
+          } else {
+          }
+          if (x >= LOG_MAX_VALUE) {
+              final double t = exp(0.5 * x);
+              return (0.5 * t) * t;
+          } else {
-      if (x < -20) {
+      } else if (x < -20) {
+          if (x <= -LOG_MAX_VALUE) {
+              final double t = exp(-0.5 * x);
+              return (-0.5 * t) * t;
+          } else {
+          }"
Math 18,junit.framework.AssertionFailedError,"expArithMod
expLogicMod
wrongComp","-                res[i] = (x[i] - boundaries[0][i]) / diff;
-                res[i] = diff * x[i] + boundaries[0][i];
-                if (x[i] < 0) {
-                if (x[i] > 1.0) {","+                res[i] = x[i] / diff;
+                res[i] = diff * x[i];
+            final double[] bLoEnc = encode(boundaries[0]);
+            final double[] bHiEnc = encode(boundaries[1]);
+                if (x[i] < bLoEnc[i]) {
+                if (x[i] > bHiEnc[i]) {","-                res[i] = (x[i] - boundaries[0][i]) / diff;
+                res[i] = x[i] / diff;
-                res[i] = diff * x[i] + boundaries[0][i];
+                res[i] = diff * x[i];
+            final double[] bLoEnc = encode(boundaries[0]);
+            final double[] bHiEnc = encode(boundaries[1]);
-                if (x[i] < 0) {
+                if (x[i] < bLoEnc[i]) {
-                if (x[i] > 1.0) {
+                if (x[i] > bHiEnc[i]) {"
Math 20,junit.framework.AssertionFailedError,"missNullCheckN
singleLine
wrapsIfElse",-            return,"+            return boundaries != null && isRepairMode ?
+                decode(repair(x)) :","-            return
+            return boundaries != null && isRepairMode ?
+                decode(repair(x)) :"
Math 19,java.lang.Exception,"condBlockExcAdd
missComp",,"+                for (int i = 0; i < lB.length; i++) {
+                    if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {
+                        final double max = Double.MAX_VALUE + boundaries[0][i];
+                        final NumberIsTooLargeException e
+                            = new NumberIsTooLargeException(boundaries[1][i],
+                                                            max,
+                                                            true);
+                        e.getContext().addMessage(LocalizedFormats.OVERFLOW);
+                        e.getContext().addMessage(LocalizedFormats.INDEX, i);
+                        throw e;
+                    }
+                }","+                for (int i = 0; i < lB.length; i++) {
+                    if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {
+                        final double max = Double.MAX_VALUE + boundaries[0][i];
+                        final NumberIsTooLargeException e
+                            = new NumberIsTooLargeException(boundaries[1][i],
+                                                            max,
+                                                            true);
+                        e.getContext().addMessage(LocalizedFormats.OVERFLOW);
+                        e.getContext().addMessage(LocalizedFormats.INDEX, i);
+                        throw e;
+                    }
+                }"
Math 23,junit.framework.AssertionFailedError,wrapsMethod,"-                        return best(current, previous, isMinim);
-                return","+        UnivariatePointValuePair best = current;
+                best = best(best,
+                            best(current,
+                                 previous,
+                                 isMinim),
+                            isMinim);
+                        return best;
+                return best(best,
+                                 isMinim),","+        UnivariatePointValuePair best = current;
+                best = best(best,
+                            best(current,
+                                 previous,
+                                 isMinim),
+                            isMinim);
-                        return best(current, previous, isMinim);
+                        return best;
-                return
+                return best(best,
+                                 isMinim),"
Math 21,junit.framework.AssertionFailedError,"expArithMod
expLogicMod
wrongComp
wrongVarRef","-        int[] swap  = new int[order];
-            swap[r] = r;
-                int isi = index[swap[i]];
-                if (c[ii][ii] > c[isi][isi]) {
-                    swap[r] = i;
-            if (swap[r] != r) {
-                int tmp = index[r];
-                index[r] = index[swap[r]];
-                index[swap[r]] = tmp;
-                    c[ii][ii] -= e * e;","+            int swapR = r;
+                int isr = index[swapR];
+                if (c[ii][ii] > c[isr][isr]) {
+                    swapR = i;
+            if (swapR != r) {
+                final int tmpIndex    = index[r];
+                index[r]              = index[swapR];
+                index[swapR]          = tmpIndex;
+                final double[] tmpRow = b[r];
+                b[r]                  = b[swapR];
+                b[swapR]              = tmpRow;
+                final double inverse2 = 1 / c[ir][ir];
+                    c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2;","-        int[] swap  = new int[order];
-            swap[r] = r;
+            int swapR = r;
-                int isi = index[swap[i]];
-                if (c[ii][ii] > c[isi][isi]) {
-                    swap[r] = i;
+                int isr = index[swapR];
+                if (c[ii][ii] > c[isr][isr]) {
+                    swapR = i;
-            if (swap[r] != r) {
-                int tmp = index[r];
-                index[r] = index[swap[r]];
-                index[swap[r]] = tmp;
+            if (swapR != r) {
+                final int tmpIndex    = index[r];
+                index[r]              = index[swapR];
+                index[swapR]          = tmpIndex;
+                final double[] tmpRow = b[r];
+                b[r]                  = b[swapR];
+                b[swapR]              = tmpRow;
+                final double inverse2 = 1 / c[ir][ir];
-                    c[ii][ii] -= e * e;
+                    c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2;"
Math 24,junit.framework.AssertionFailedError,"copyPaste
wrapsMethod","-                        return current;
-                return current;","+                        return best(current, previous, isMinim);
+                return best(current, previous, isMinim);","-                        return current;
+                        return best(current, previous, isMinim);
-                return current;
+                return best(current, previous, isMinim);"
Math 30,junit.framework.AssertionFailedError,singleLine,-        final int n1n2prod = n1 * n2;,+        final double n1n2prod = n1 * n2;,"-        final int n1n2prod = n1 * n2;
+        final double n1n2prod = n1 * n2;"
Math 25,junit.framework.AssertionFailedError,condBlockExcAdd,,"+                if (c2 == 0) {
+                    throw new MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR);
+                }","+                if (c2 == 0) {
+                    throw new MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR);
+                }"
Math 26,junit.framework.AssertionFailedError,"expLogicMod
wrapsMethod","-        if (a0 > overflow) {
-            if ((p2 > overflow) || (q2 > overflow)) {","+        if (FastMath.abs(a0) > overflow) {
+            if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {","-        if (a0 > overflow) {
+        if (FastMath.abs(a0) > overflow) {
-            if ((p2 > overflow) || (q2 > overflow)) {
+            if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {"
Math 27,junit.framework.AssertionFailedError,"expArithMod
singleLine
unwrapMethod",-        return multiply(100).doubleValue();,+        return 100 * doubleValue();,"-        return multiply(100).doubleValue();
+        return 100 * doubleValue();"
Math 29,junit.framework.AssertionFailedError,"condBlockOthersAdd
missComp
wrongComp","-        Iterator iter = entries.iterator();
-        while (iter.hasNext()) {
-            iter.advance();
-            res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));","+        final int n = getDimension();
+        for (int i = 0; i < n; i++) {
+            res.setEntry(i, this.getEntry(i) / v.getEntry(i));
+        if (v.isNaN() || v.isInfinite()) {
+            final int n = getDimension();
+            for (int i = 0; i < n; i++) {
+                final double y = v.getEntry(i);
+                if (Double.isNaN(y)) {
+                    res.setEntry(i, Double.NaN);
+                } else if (Double.isInfinite(y)) {
+                    final double x = this.getEntry(i);
+                    res.setEntry(i, x * y);
+                }
+            }
+        }","-        Iterator iter = entries.iterator();
-        while (iter.hasNext()) {
-            iter.advance();
-            res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));
+        final int n = getDimension();
+        for (int i = 0; i < n; i++) {
+            res.setEntry(i, this.getEntry(i) / v.getEntry(i));
+        if (v.isNaN() || v.isInfinite()) {
+            final int n = getDimension();
+            for (int i = 0; i < n; i++) {
+                final double y = v.getEntry(i);
+                if (Double.isNaN(y)) {
+                    res.setEntry(i, Double.NaN);
+                } else if (Double.isInfinite(y)) {
+                    final double x = this.getEntry(i);
+                    res.setEntry(i, x * y);
+                }
+            }
+        }"
Math 28,org.apache.commons.math3.exception.MaxCountExceededException,wrapsIf,,"+            if (tableau.getNumArtificialVariables() > 0) {
+            }
+            if (getIterations() < getMaxIterations() / 2) {
+            }","+            if (tableau.getNumArtificialVariables() > 0) {
+            }
+            if (getIterations() < getMaxIterations() / 2) {
+            }"
Math 31,org.apache.commons.math3.exception.ConvergenceException,"blockRemove
condBlockOthersAdd
condBlockRem
expArithMod
wrongComp
wrongVarRef","-        double p0 = 1.0;
-        double q1 = 1.0;
-            double cN = a * hPrev + b * p0;
-            double q2 = a * q1 + b * dPrev;
-            if (Double.isInfinite(cN) || Double.isInfinite(q2)) {
-                double scaleFactor = 1d;
-                double lastScaleFactor = 1d;
-                final int maxPower = 5;
-                final double scale = FastMath.max(a,b);
-                if (scale <= 0) {  // Can't scale
-                    throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);
-                }
-                for (int i = 0; i < maxPower; i++) {
-                    lastScaleFactor = scaleFactor;
-                    scaleFactor *= scale;
-                    if (a != 0.0 && a > b) {
-                        cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);
-                        q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);
-                    } else if (b != 0) {
-                        cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;
-                        q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;
-                    }
-                    if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {
-                        break;
-                    }
-                }
-            final double deltaN = cN / q2 / cPrev;
-            hN = cPrev * deltaN;
-            dPrev = q1;
-            cPrev = cN / q2;
-            p0 = hPrev;
-            hPrev = cN;
-            q1 = q2;","+            double dN = a + b * dPrev;
+            if (Precision.equals(dN, 0.0, small)) {
+                dN = small;
+            }
+            double cN = a + b / cPrev;
+            if (Precision.equals(cN, 0.0, small)) {
+                cN = small;
+            dN = 1 / dN;
+            final double deltaN = cN * dN;
+            hN = hPrev * deltaN;
+            dPrev = dN;
+            cPrev = cN;
+            hPrev = hN;","-        double p0 = 1.0;
-        double q1 = 1.0;
-            double cN = a * hPrev + b * p0;
-            double q2 = a * q1 + b * dPrev;
-            if (Double.isInfinite(cN) || Double.isInfinite(q2)) {
-                double scaleFactor = 1d;
-                double lastScaleFactor = 1d;
-                final int maxPower = 5;
-                final double scale = FastMath.max(a,b);
-                if (scale <= 0) {  // Can't scale
-                    throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);
-                }
-                for (int i = 0; i < maxPower; i++) {
-                    lastScaleFactor = scaleFactor;
-                    scaleFactor *= scale;
-                    if (a != 0.0 && a > b) {
-                        cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);
-                        q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);
-                    } else if (b != 0) {
-                        cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;
-                        q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;
-                    }
-                    if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {
-                        break;
-                    }
-                }
+            double dN = a + b * dPrev;
+            if (Precision.equals(dN, 0.0, small)) {
+                dN = small;
+            }
+            double cN = a + b / cPrev;
+            if (Precision.equals(cN, 0.0, small)) {
+                cN = small;
-            final double deltaN = cN / q2 / cPrev;
-            hN = cPrev * deltaN;
+            dN = 1 / dN;
+            final double deltaN = cN * dN;
+            hN = hPrev * deltaN;
-            dPrev = q1;
-            cPrev = cN / q2;
-            p0 = hPrev;
-            hPrev = cN;
-            q1 = q2;
+            dPrev = dN;
+            cPrev = cN;
+            hPrev = hN;"
Math 32,java.lang.ClassCastException,"expLogicExpand
missNullCheckP
singleLine",-            if ((Boolean) tree.getAttribute()) {,+            if (tree.getCut() == null && (Boolean) tree.getAttribute()) {,"-            if ((Boolean) tree.getAttribute()) {
+            if (tree.getCut() == null && (Boolean) tree.getAttribute()) {"
Math 35,junit.framework.AssertionFailedError,"copyPaste
wrapsMethod
wrongVarRef","-        this.elitismRate = elitismRate;
-        this.elitismRate = elitismRate;","+        setElitismRate(elitismRate);
+        setElitismRate(elitismRate);","-        this.elitismRate = elitismRate;
+        setElitismRate(elitismRate);
-        this.elitismRate = elitismRate;
+        setElitismRate(elitismRate);"
Math 33,junit.framework.AssertionFailedError,"expLogicMod
singleLine
wrongVarRef","-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {","+            if (Precision.compareTo(entry, 0d, epsilon) > 0) {","-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
+            if (Precision.compareTo(entry, 0d, epsilon) > 0) {"
Math 37,junit.framework.AssertionFailedError,"condBlockRetAdd
copyPaste
expLogicExpand
missComp","-        if (isNaN) {
-        if (isNaN) {","+        if (isNaN || Double.isInfinite(real)) {
+        if (imaginary > 20.0) {
+            return createComplex(0.0, 1.0);
+        }
+        if (imaginary < -20.0) {
+            return createComplex(0.0, -1.0);
+        }
+        if (isNaN || Double.isInfinite(imaginary)) {
+        if (real > 20.0) {
+            return createComplex(1.0, 0.0);
+        }
+        if (real < -20.0) {
+            return createComplex(-1.0, 0.0);
+        }","-        if (isNaN) {
+        if (isNaN || Double.isInfinite(real)) {
+        if (imaginary > 20.0) {
+            return createComplex(0.0, 1.0);
+        }
+        if (imaginary < -20.0) {
+            return createComplex(0.0, -1.0);
+        }
-        if (isNaN) {
+        if (isNaN || Double.isInfinite(imaginary)) {
+        if (real > 20.0) {
+            return createComplex(1.0, 0.0);
+        }
+        if (real < -20.0) {
+            return createComplex(-1.0, 0.0);
+        }"
Math 34,junit.framework.AssertionFailedError,"missComp
singleLine
wrongVarRef",-        return chromosomes.iterator();,+        return getChromosomes().iterator();,"-        return chromosomes.iterator();
+        return getChromosomes().iterator();"
Math 40,org.apache.commons.math.exception.TooManyEvaluationsException,"copyPaste
expArithMod
wrongComp","-                targetY = -REDUCTION_FACTOR * yB;
-                targetY = -REDUCTION_FACTOR * yA;","+                final int p = agingA - MAXIMAL_AGING;
+                final double weightA = (1 << p) - 1;
+                final double weightB = p + 1;
+                targetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB);
+                final int p = agingB - MAXIMAL_AGING;
+                final double weightA = p + 1;
+                final double weightB = (1 << p) - 1;
+                targetY = (weightB * yB - weightA * REDUCTION_FACTOR * yA) / (weightA + weightB);","-                targetY = -REDUCTION_FACTOR * yB;
+                final int p = agingA - MAXIMAL_AGING;
+                final double weightA = (1 << p) - 1;
+                final double weightB = p + 1;
+                targetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB);
-                targetY = -REDUCTION_FACTOR * yA;
+                final int p = agingB - MAXIMAL_AGING;
+                final double weightA = p + 1;
+                final double weightB = (1 << p) - 1;
+                targetY = (weightB * yB - weightA * REDUCTION_FACTOR * yA) / (weightA + weightB);"
Math 38,org.apache.commons.math.optimization.direct.BOBYQAOptimizer$PathIsExploredException,"copyPaste
expArithMod
initFix
wrongComp","-                    throw new PathIsExploredException(); // XXX
-                final int iptMinus1 = ipt;
-                final int jptMinus1 = jpt;
-                throw new PathIsExploredException(); // XXX","+                final int iptMinus1 = ipt - 1;
+                final int jptMinus1 = jpt - 1;","-                    throw new PathIsExploredException(); // XXX
-                final int iptMinus1 = ipt;
-                final int jptMinus1 = jpt;
+                final int iptMinus1 = ipt - 1;
+                final int jptMinus1 = jpt - 1;
-                throw new PathIsExploredException(); // XXX"
Math 39,junit.framework.AssertionFailedError,"condBlockOthersAdd
missComp",,"+        if (forward) {
+            if (stepStart + stepSize >= t) {
+                stepSize = t - stepStart;
+            }
+        } else {
+            if (stepStart + stepSize <= t) {
+                stepSize = t - stepStart;
+            }
+        }","+        if (forward) {
+            if (stepStart + stepSize >= t) {
+                stepSize = t - stepStart;
+            }
+        } else {
+            if (stepStart + stepSize <= t) {
+                stepSize = t - stepStart;
+            }
+        }"
Math 36,junit.framework.AssertionFailedError,"condBlockOthersAdd
copyPaste
missComp",,"+        if (Double.isNaN(result)) {
+            int shift = Math.max(numerator.bitLength(),
+                                 denominator.bitLength()) - Double.MAX_EXPONENT;
+            result = numerator.shiftRight(shift).doubleValue() /
+                denominator.shiftRight(shift).doubleValue();
+        }
+        if (Double.isNaN(result)) {
+            int shift = Math.max(numerator.bitLength(),
+                                 denominator.bitLength()) - Float.MAX_EXPONENT;
+            result = numerator.shiftRight(shift).floatValue() /
+                denominator.shiftRight(shift).floatValue();
+        }","+        if (Double.isNaN(result)) {
+            int shift = Math.max(numerator.bitLength(),
+                                 denominator.bitLength()) - Double.MAX_EXPONENT;
+            result = numerator.shiftRight(shift).doubleValue() /
+                denominator.shiftRight(shift).doubleValue();
+        }
+        if (Double.isNaN(result)) {
+            int shift = Math.max(numerator.bitLength(),
+                                 denominator.bitLength()) - Float.MAX_EXPONENT;
+            result = numerator.shiftRight(shift).floatValue() /
+                denominator.shiftRight(shift).floatValue();
+        }"
Math 42,junit.framework.AssertionFailedError,"missNullCheckN
wrapsIfElse
wrongComp",-          if (basicRows.contains(basicRow)) {,"+          if (basicRow != null && basicRow == 0) {
+              coefficients[i] = 0;
+          } else if (basicRows.contains(basicRow)) {","+          if (basicRow != null && basicRow == 0) {
-          if (basicRows.contains(basicRow)) {
+              coefficients[i] = 0;
+          } else if (basicRows.contains(basicRow)) {"
Math 41,junit.framework.AssertionFailedError,"initFix
singleLine
wrongVarRef",-                for (int i = 0; i < weights.length; i++) {,+                for (int i = begin; i < begin + length; i++) {,"-                for (int i = 0; i < weights.length; i++) {
+                for (int i = begin; i < begin + length; i++) {"
Math 44,junit.framework.AssertionFailedError,"copyPaste
missComp",-            resetOccurred = false;,"+                    for (final EventState remaining : occuringEvents) {
+                        remaining.stepAccepted(eventT, eventY);
+                    }
+                    for (final EventState remaining : occuringEvents) {
+                        remaining.stepAccepted(eventT, eventY);
+                    }","-            resetOccurred = false;
+                    for (final EventState remaining : occuringEvents) {
+                        remaining.stepAccepted(eventT, eventY);
+                    }
+                    for (final EventState remaining : occuringEvents) {
+                        remaining.stepAccepted(eventT, eventY);
+                    }"
Math 43,junit.framework.AssertionFailedError,expLogicMod,"-        if (!(meanImpl instanceof Mean)) {
-        if (!(varianceImpl instanceof Variance)) {
-        if (!(geoMeanImpl instanceof GeometricMean)) {","+        if (meanImpl != mean) {
+        if (varianceImpl != variance) {
+        if (geoMeanImpl != geoMean) {","-        if (!(meanImpl instanceof Mean)) {
+        if (meanImpl != mean) {
-        if (!(varianceImpl instanceof Variance)) {
+        if (varianceImpl != variance) {
-        if (!(geoMeanImpl instanceof GeometricMean)) {
+        if (geoMeanImpl != geoMean) {"
Math 47,junit.framework.AssertionFailedError,"copyPaste
expLogicMod
wrapsIfElse
wrongComp","-        if (divisor.getReal() == 0.0 && divisor.getImaginary() == 0.0) {
-            return NaN;
-            return NaN;","+    private final transient boolean isZero;
+        isZero = real == 0 && imaginary == 0;
+        if (divisor.isZero) {
+            return isZero ? NaN : INF;
+            return isZero ? NaN : INF;","+    private final transient boolean isZero;
+        isZero = real == 0 && imaginary == 0;
-        if (divisor.getReal() == 0.0 && divisor.getImaginary() == 0.0) {
-            return NaN;
+        if (divisor.isZero) {
+            return isZero ? NaN : INF;
-            return NaN;
+            return isZero ? NaN : INF;"
Math 48,java.lang.Exception,condBlockExcAdd,,"+                    if (x == x1) {
+                        throw new ConvergenceException();
+                    }","+                    if (x == x1) {
+                        throw new ConvergenceException();
+                    }"
Math 50,junit.framework.AssertionFailedError,condBlockRem,"-                    if (x == x1) {
-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));
-                        f0 = computeObjectiveValue(x0);
-                    }",,"-                    if (x == x1) {
-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));
-                        f0 = computeObjectiveValue(x0);
-                    }"
Math 49,org.apache.commons.math.MathRuntimeException$6,"copyPaste
wrongVarRef","-        Iterator iter = res.entries.iterator();
-        Iterator iter = res.entries.iterator();
-        Iterator iter = res.entries.iterator();
-        Iterator iter = res.entries.iterator();","+        Iterator iter = entries.iterator();
+        Iterator iter = entries.iterator();
+        Iterator iter = entries.iterator();
+        Iterator iter = entries.iterator();","-        Iterator iter = res.entries.iterator();
+        Iterator iter = entries.iterator();
-        Iterator iter = res.entries.iterator();
+        Iterator iter = entries.iterator();
-        Iterator iter = res.entries.iterator();
+        Iterator iter = entries.iterator();
-        Iterator iter = res.entries.iterator();
+        Iterator iter = entries.iterator();"
Math 46,junit.framework.AssertionFailedError,"copyPaste
unwrapIfElse","-            return isZero ? NaN : INF;
-            return isZero ? NaN : INF;","+            return NaN;
+            return NaN;","-            return isZero ? NaN : INF;
+            return NaN;
-            return isZero ? NaN : INF;
+            return NaN;"
Math 45,junit.framework.AssertionFailedError,condBlockExcAdd,,"+        long lRow = (long) rowDimension;
+        long lCol = (long) columnDimension;
+        if (lRow * lCol >= (long) Integer.MAX_VALUE) {
+            throw new NumberIsTooLargeException(lRow * lCol, Integer.MAX_VALUE, false);
+        }","+        long lRow = (long) rowDimension;
+        long lCol = (long) columnDimension;
+        if (lRow * lCol >= (long) Integer.MAX_VALUE) {
+            throw new NumberIsTooLargeException(lRow * lCol, Integer.MAX_VALUE, false);
+        }"
Math 51,org.apache.commons.math.exception.TooManyEvaluationsException,condBlockOthersAdd,,"+                case REGULA_FALSI:
+                    if (x == x1) {
+                        final double delta = FastMath.max(rtol * FastMath.abs(x1),
+                                                          atol);
+                        x0 = 0.5 * (x0 + x1 - delta);
+                        f0 = computeObjectiveValue(x0);
+                    }
+                    break;
+                    throw new MathInternalError();","+                case REGULA_FALSI:
+                    if (x == x1) {
+                        final double delta = FastMath.max(rtol * FastMath.abs(x1),
+                                                          atol);
+                        x0 = 0.5 * (x0 + x1 - delta);
+                        f0 = computeObjectiveValue(x0);
+                    }
+                    break;
+                    throw new MathInternalError();"
Math 58,org.apache.commons.math.exception.NotStrictlyPositiveException,"singleLine
wrongMethodRef","-        return fit(new Gaussian.Parametric(), guess);",+        return fit(guess);,"-        return fit(new Gaussian.Parametric(), guess);
+        return fit(guess);"
Math 59,junit.framework.AssertionFailedError,"singleLine
wrongVarRef",-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);,+        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);,"-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);
+        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);"
Math 57,junit.framework.AssertionFailedError,singleLine,-            int sum = 0;,+            double sum = 0;,"-            int sum = 0;
+            double sum = 0;"
Math 53,junit.framework.AssertionFailedError,condBlockRetAdd,,"+        if (isNaN || rhs.isNaN) {
+            return NaN;
+        }","+        if (isNaN || rhs.isNaN) {
+            return NaN;
+        }"
Math 61,org.apache.commons.math.MathRuntimeException$4,"initFix
notClassified","-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);","+            throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, p);","-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);
+            throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, p);"
Math 55,junit.framework.AssertionFailedError,"condBlockRetAdd
expArithMod
initFix
wrongComp","-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);","+      final double n1 = v1.getNormSq();
+      final double n2 = v2.getNormSq();
+      if ((n1 * n2) < MathUtils.SAFE_MIN) {
+          return ZERO;
+      }
+      final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4;
+      final double x1    = FastMath.scalb(v1.x, -deltaExp);
+      final double y1    = FastMath.scalb(v1.y, -deltaExp);
+      final double z1    = FastMath.scalb(v1.z, -deltaExp);
+      final double x2    = FastMath.scalb(v2.x,  deltaExp);
+      final double y2    = FastMath.scalb(v2.y,  deltaExp);
+      final double z2    = FastMath.scalb(v2.z,  deltaExp);
+      final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp);
+      final double rho   = FastMath.rint(256 * ratio) / 256;
+      final double x3 = x1 - rho * x2;
+      final double y3 = y1 - rho * y2;
+      final double z3 = z1 - rho * z2;
+      return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);","+      final double n1 = v1.getNormSq();
+      final double n2 = v2.getNormSq();
+      if ((n1 * n2) < MathUtils.SAFE_MIN) {
+          return ZERO;
+      }
+      final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4;
+      final double x1    = FastMath.scalb(v1.x, -deltaExp);
+      final double y1    = FastMath.scalb(v1.y, -deltaExp);
+      final double z1    = FastMath.scalb(v1.z, -deltaExp);
+      final double x2    = FastMath.scalb(v2.x,  deltaExp);
+      final double y2    = FastMath.scalb(v2.y,  deltaExp);
+      final double z2    = FastMath.scalb(v2.z,  deltaExp);
+      final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp);
+      final double rho   = FastMath.rint(256 * ratio) / 256;
+      final double x3 = x1 - rho * x2;
+      final double y3 = y1 - rho * y2;
+      final double z3 = z1 - rho * z2;
-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);
+      return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);"
Math 60,org.apache.commons.math.ConvergenceException,"blockRemove
condBlockRem
condBlockRetAdd
unwrapTryCatch","-        try {
-        } catch (MaxIterationsExceededException ex) {
-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38
-                return 0;
-            } else if (x > (mean + 20 * standardDeviation)) {
-                return 1;
-            } else {
-                throw ex;
-            }
-        }","+        if (FastMath.abs(dev) > 40 * standardDeviation) { 
+            return dev < 0 ? 0.0d : 1.0d;
+        }","-        try {
+        if (FastMath.abs(dev) > 40 * standardDeviation) { 
+            return dev < 0 ? 0.0d : 1.0d;
+        }
-        } catch (MaxIterationsExceededException ex) {
-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38
-                return 0;
-            } else if (x > (mean + 20 * standardDeviation)) {
-                return 1;
-            } else {
-                throw ex;
-            }
-        }"
Math 54,junit.framework.AssertionFailedError,"condBlockOthersAdd
wrapsIfElse",-        if (lessThan(getZero())) {,"+                if ((bits & 0x8000000000000000L) != 0) {
+                    sign = -1;
+                }
+        int cmp0 = compare(this, getZero());
+        if (cmp0 == 0) {
+            return sign < 0 ? -0.0 : +0.0;
+        } else if (cmp0 < 0) {","+                if ((bits & 0x8000000000000000L) != 0) {
+                    sign = -1;
+                }
-        if (lessThan(getZero())) {
+        int cmp0 = compare(this, getZero());
+        if (cmp0 == 0) {
+            return sign < 0 ? -0.0 : +0.0;
+        } else if (cmp0 < 0) {"
Math 56,junit.framework.AssertionFailedError,"blockRemove
expArithMod
wrongComp","-        int idx = 1;
-        while (count < index) {
-            count += idx;
-            ++idx;
-        }
-        --idx;
-        indices[last] = idx;",+        indices[last] = index - count;,"-        int idx = 1;
-        while (count < index) {
-            count += idx;
-            ++idx;
-        }
-        --idx;
-        indices[last] = idx;
+        indices[last] = index - count;"
Math 52,junit.framework.AssertionFailedError,"expLogicMod
initFix","-  if (c == 0) {
-    if (c == 0) {
-      if (c == 0) {","+  final double inPlaneThreshold = 0.001;
+  if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) {
+    if (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) {
+      if (c <= 0) {","-  if (c == 0) {
+  final double inPlaneThreshold = 0.001;
+  if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) {
-    if (c == 0) {
+    if (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) {
-      if (c == 0) {
+      if (c <= 0) {"
Math 63,junit.framework.AssertionFailedError,"expLogicMod
singleLine",-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;,"+        return equals(x, y, 1);","-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;
+        return equals(x, y, 1);"
Math 62,junit.framework.AssertionFailedError,"expArithMod
wrongComp
wrongMethodRef","-        return optimize(f, goal, min, max, 0);
-                final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);
-                final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);
-                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));","+        return optimize(f, goal, min, max, min + 0.5 * (max - min));
+                final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min);
+                optima[i] = optimizer.optimize(f, goal, min, max, s);","-        return optimize(f, goal, min, max, 0);
+        return optimize(f, goal, min, max, min + 0.5 * (max - min));
-                final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);
-                final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);
-                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));
+                final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min);
+                optima[i] = optimizer.optimize(f, goal, min, max, s);"
Math 66,junit.framework.AssertionFailedError,"constChange
expLogicMod
initFix
wrongComp
wrongMethodRef
wrongVarRef","-        setMaxEvaluations(Integer.MAX_VALUE);
-        setAbsoluteAccuracy(1E-10);
-        setRelativeAccuracy(1.0e-14);
-        throw new UnsupportedOperationException();
-    }
-    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {
-        clearResult();
-                        f, goalType, min, startValue, max,
-    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {
-        return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));
-    }
-                            UnivariateRealFunction f,
-                            GoalType goalType,
-        double fx = computeObjectiveValue(f, x);
-        if (goalType == GoalType.MAXIMIZE) {
-        int count = 0;
-        while (count < maximalIterationCount) {
-                double fu = computeObjectiveValue(f, u);
-                if (goalType == GoalType.MAXIMIZE) {
-                setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);
-            ++count;
-        throw new MaxIterationsExceededException(maximalIterationCount);","+        setMaxEvaluations(1000);
+        setAbsoluteAccuracy(1e-11);
+        setRelativeAccuracy(1e-9);
+                        getMin(), getStartValue(), getMax(),
+        double fx = computeObjectiveValue(x);
+        if (!isMinim) {
+        while (true) {
+                double fu = computeObjectiveValue(u);
+                if (!isMinim) {
+                setFunctionValue(isMinim ? fx : -fx);
+            incrementIterationsCounter();","-        setMaxEvaluations(Integer.MAX_VALUE);
+        setMaxEvaluations(1000);
-        setAbsoluteAccuracy(1E-10);
-        setRelativeAccuracy(1.0e-14);
+        setAbsoluteAccuracy(1e-11);
+        setRelativeAccuracy(1e-9);
-        throw new UnsupportedOperationException();
-    }
-    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {
-        clearResult();
-                        f, goalType, min, startValue, max,
+                        getMin(), getStartValue(), getMax(),
-    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {
-        return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));
-    }
-                            UnivariateRealFunction f,
-                            GoalType goalType,
-        double fx = computeObjectiveValue(f, x);
-        if (goalType == GoalType.MAXIMIZE) {
+        double fx = computeObjectiveValue(x);
+        if (!isMinim) {
-        int count = 0;
-        while (count < maximalIterationCount) {
+        while (true) {
-                double fu = computeObjectiveValue(f, u);
-                if (goalType == GoalType.MAXIMIZE) {
+                double fu = computeObjectiveValue(u);
+                if (!isMinim) {
-                setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);
+                setFunctionValue(isMinim ? fx : -fx);
-            ++count;
+            incrementIterationsCounter();
-        throw new MaxIterationsExceededException(maximalIterationCount);"
Math 65,junit.framework.AssertionFailedError,"blockRemove
expArithMod
wrongVarRef","-        double criterion = 0;
-        for (int i = 0; i < rows; ++i) {
-            final double residual = residuals[i];
-            criterion += residual * residual * residualsWeights[i];
-        }
-        return Math.sqrt(criterion / rows);
-            chiSquare += residual * residual / residualsWeights[i];","+        return Math.sqrt(getChiSquare() / rows);
+            chiSquare += residual * residual * residualsWeights[i];","-        double criterion = 0;
-        for (int i = 0; i < rows; ++i) {
-            final double residual = residuals[i];
-            criterion += residual * residual * residualsWeights[i];
-        }
-        return Math.sqrt(criterion / rows);
+        return Math.sqrt(getChiSquare() / rows);
-            chiSquare += residual * residual / residualsWeights[i];
+            chiSquare += residual * residual * residualsWeights[i];"
Math 64,junit.framework.AssertionFailedError,"blockRemove
codeMove
condBlockOthersAdd
condBlockRem
condBlockRetAdd
expArithMod
missNullCheckN
wrongComp
wrongVarRef","-            qTy(residuals);
-                            sum += jacobian[i][pj] * residuals[i];
-                determineLMParameter(oldRes, delta, diag, work1, work2, work3);
-                current = new VectorialPointValuePair(point, objective);
-                } else {
-                    if (checker.converged(getIterations(), previous, current)) {
-                        return current;
-                    }","+        double[] oldObj  = new double[rows];
+        double[] qtf     = new double[rows];
+            for (int i=0;i<rows;i++) {
+                qtf[i]=residuals[i];
+            }
+            qTy(qtf);
+                            sum += jacobian[i][pj] * qtf[i];
+            	updateResidualsAndCost();
+            	current = new VectorialPointValuePair(point, objective);
+                tmpVec    = objective;
+                objective = oldObj;
+                oldObj    = tmpVec;
+                determineLMParameter(qtf, delta, diag, work1, work2, work3);
+                    current = new VectorialPointValuePair(point, objective);
+                    if (checker != null) {
+                    	if (checker.converged(getIterations(), previous, current)) {
+                    		return current;
+                    	}
+                    }
+                    tmpVec    = objective;
+                    objective = oldObj;
+                    oldObj    = tmpVec;","+        double[] oldObj  = new double[rows];
+        double[] qtf     = new double[rows];
+            for (int i=0;i<rows;i++) {
+                qtf[i]=residuals[i];
+            }
-            qTy(residuals);
+            qTy(qtf);
-                            sum += jacobian[i][pj] * residuals[i];
+                            sum += jacobian[i][pj] * qtf[i];
+            	updateResidualsAndCost();
+            	current = new VectorialPointValuePair(point, objective);
+                tmpVec    = objective;
+                objective = oldObj;
+                oldObj    = tmpVec;
-                determineLMParameter(oldRes, delta, diag, work1, work2, work3);
+                determineLMParameter(qtf, delta, diag, work1, work2, work3);
-                current = new VectorialPointValuePair(point, objective);
+                    current = new VectorialPointValuePair(point, objective);
+                    if (checker != null) {
+                    	if (checker.converged(getIterations(), previous, current)) {
+                    		return current;
+                    	}
+                    }
+                    tmpVec    = objective;
+                    objective = oldObj;
+                    oldObj    = tmpVec;
-                } else {
-                    if (checker.converged(getIterations(), previous, current)) {
-                        return current;
-                    }"
Math 70,java.lang.NullPointerException,"singleLine
wrongMethodRef","-        return solve(min, max);","+        return solve(f, min, max);","-        return solve(min, max);
+        return solve(f, min, max);"
Math 68,junit.framework.AssertionFailedError,"condBlockRetAdd
missNullCheckN
wrapsIfElse","-                return new VectorialPointValuePair(point, objective);
-                        return new VectorialPointValuePair(point, objective);","+        setConvergenceChecker(null);
+        VectorialPointValuePair current = new VectorialPointValuePair(point, objective);
+            VectorialPointValuePair previous = current;
+                return current;
+                current = new VectorialPointValuePair(point, objective);
+                if (checker != null) {
+                    if (checker.converged(getIterations(), previous, current)) {
+                        return current;                        
+                    }
+                } else {
+                        return current;
+                }","+        setConvergenceChecker(null);
+        VectorialPointValuePair current = new VectorialPointValuePair(point, objective);
+            VectorialPointValuePair previous = current;
-                return new VectorialPointValuePair(point, objective);
+                return current;
+                current = new VectorialPointValuePair(point, objective);
+                if (checker != null) {
+                    if (checker.converged(getIterations(), previous, current)) {
+                        return current;                        
+                    }
+                } else {
-                        return new VectorialPointValuePair(point, objective);
+                        return current;
+                }"
Math 69,junit.framework.AssertionFailedError,"expArithMod
singleLine
wrongComp",-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));,+                    out[i][j] = 2 * tDistribution.cumulativeProbability(-t);,"-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));
+                    out[i][j] = 2 * tDistribution.cumulativeProbability(-t);"
Math 71,junit.framework.AssertionFailedError,copyPaste,,"+                  interpolator.storeTime(stepStart);
+                  System.arraycopy(y, 0, yTmp, 0, y0.length);
+                  hNew     = 0;
+                  stepSize = 0;
+                interpolator.storeTime(stepStart);
+                System.arraycopy(y, 0, yTmp, 0, y0.length);
+                stepSize = 0;","+                  interpolator.storeTime(stepStart);
+                  System.arraycopy(y, 0, yTmp, 0, y0.length);
+                  hNew     = 0;
+                  stepSize = 0;
+                interpolator.storeTime(stepStart);
+                System.arraycopy(y, 0, yTmp, 0, y0.length);
+                stepSize = 0;"
Math 72,junit.framework.AssertionFailedError,"wrongComp
wrongVarRef","-            setResult(yMin, 0);
-            setResult(yMax, 0);","+            setResult(min, 0);
+            setResult(max, 0);","-            setResult(yMin, 0);
+            setResult(min, 0);
-            setResult(yMax, 0);
+            setResult(max, 0);"
Math 67,junit.framework.AssertionFailedError,wrongMethodRef,"-        return optimizer.getFunctionValue();
-        return optimizer.getResult();","+        return optimaValues[0];
+        return optima[0];","-        return optimizer.getFunctionValue();
+        return optimaValues[0];
-        return optimizer.getResult();
+        return optima[0];"
Math 73,junit.framework.AssertionFailedError,condBlockExcAdd,,"+        if (yMin * yMax > 0) {
+            throw MathRuntimeException.createIllegalArgumentException(
+                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);
+        }","+        if (yMin * yMax > 0) {
+            throw MathRuntimeException.createIllegalArgumentException(
+                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);
+        }"
Math 74,junit.framework.AssertionFailedError,"initFix
notClassified
wrongComp","-          final double[] scale;
-              scale = new double[y0.length];
-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);
-              scale = vecAbsoluteTolerance;","+          final double[] scale = new double[y0.length];
+              for (int i = 0; i < scale.length; ++i) {
+                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);
+              }
+              for (int i = 0; i < scale.length; ++i) {
+                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);
+              }","-          final double[] scale;
+          final double[] scale = new double[y0.length];
-              scale = new double[y0.length];
-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);
+              for (int i = 0; i < scale.length; ++i) {
+                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);
+              }
-              scale = vecAbsoluteTolerance;
+              for (int i = 0; i < scale.length; ++i) {
+                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);
+              }"
Math 75,junit.framework.AssertionFailedError,"singleLine
wrongMethodRef",-        return getCumPct((Comparable<?>) v);,+        return getPct((Comparable<?>) v);,"-        return getCumPct((Comparable<?>) v);
+        return getPct((Comparable<?>) v);"
Math 77,junit.framework.AssertionFailedError,"blockRemove
expArithMod
wrongComp","-            max += Math.max(max, Math.abs(a));
-    public double getLInfNorm() {
-        double max = 0;
-        Iterator iter = entries.iterator();
-        while (iter.hasNext()) {
-            iter.advance();
-            max += iter.value();
-        }
-        return max;
-    }","+            max = Math.max(max, Math.abs(a));","-            max += Math.max(max, Math.abs(a));
+            max = Math.max(max, Math.abs(a));
-    public double getLInfNorm() {
-        double max = 0;
-        Iterator iter = entries.iterator();
-        while (iter.hasNext()) {
-            iter.advance();
-            max += iter.value();
-        }
-        return max;
-    }"
Math 82,junit.framework.AssertionFailedError,"expLogicMod
singleLine","-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {","+            if (MathUtils.compareTo(entry, 0, epsilon) > 0) {","-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {
+            if (MathUtils.compareTo(entry, 0, epsilon) > 0) {"
Math 76,junit.framework.AssertionFailedError,"copyPaste
expArithMod
expLogicMod
wrapsIfElse
wrongVarRef","-                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);
-                for (int i = 0; i < p - 1; ++i) {
-                }
-                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];
-                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);
-                for (int i = 0; i < p - 1; ++i) {
-                }
-                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];","+                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);
+                for (int i = 0; i < p; ++i) {
+                    if (i < n - 1) {
+                    } else {
+                            wi[j] = mi * ei0[j] / singularValues[j];
+                    }
+                }
+                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);
+                for (int i = 0; i < p; ++i) {
+                    if (i < m - 1) {
+                    } else {
+                            wi[j] = mi * ei0[j] / singularValues[j];
+                    }
+                }","-                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);
+                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);
-                for (int i = 0; i < p - 1; ++i) {
+                for (int i = 0; i < p; ++i) {
+                    if (i < n - 1) {
-                }
+                    } else {
-                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];
+                            wi[j] = mi * ei0[j] / singularValues[j];
+                    }
+                }
-                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);
+                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);
-                for (int i = 0; i < p - 1; ++i) {
+                for (int i = 0; i < p; ++i) {
+                    if (i < m - 1) {
-                }
+                    } else {
-                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];
+                            wi[j] = mi * ei0[j] / singularValues[j];
+                    }
+                }"
Math 84,junit.framework.AssertionFailedError,"condBlockRetAdd
missComp",,"+        final RealConvergenceChecker checker = getConvergenceChecker();
+                return;
+            }
+            final int iter = getIterations();
+            boolean converged = true;
+            for (int i = 0; i < simplex.length; ++i) {
+                converged &= checker.converged(iter, original[i], simplex[i]);
+            }
+            if (converged) {","+        final RealConvergenceChecker checker = getConvergenceChecker();
+                return;
+            }
+            final int iter = getIterations();
+            boolean converged = true;
+            for (int i = 0; i < simplex.length; ++i) {
+                converged &= checker.converged(iter, original[i], simplex[i]);
+            }
+            if (converged) {"
Math 81,java.lang.ArrayIndexOutOfBoundsException,"constChange
expArithMod
expLogicMod
missComp","-                    for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {
-                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&
-                if (end - start > 2) {","+        upperSpectra = Math.max(upperSpectra, upper);
+                    for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) {
+                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) ||
+                if (end - start > 3) {","+        upperSpectra = Math.max(upperSpectra, upper);
-                    for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {
-                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&
+                    for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) {
+                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) ||
-                if (end - start > 2) {
+                if (end - start > 3) {"
Math 80,junit.framework.AssertionFailedError,"expArithMod
singleLine",-            int j = 4 * n - 1;,+            int j = 4 * (n - 1);,"-            int j = 4 * n - 1;
+            int j = 4 * (n - 1);"
Math 78,org.apache.commons.math.MathRuntimeException$4,"condBlockExcAdd
condBlockOthersAdd
missComp",,"+                    if (ga * gb > 0) {
+                        final double epsilon = (forward ? 0.25 : -0.25) * convergence;
+                        for (int k = 0; (k < 4) && (ga * gb > 0); ++k) {
+                            ta += epsilon;
+                            interpolator.setInterpolatedTime(ta);
+                            ga = handler.g(ta, interpolator.getInterpolatedState());
+                        }
+                        if (ga * gb > 0) {
+                            throw MathRuntimeException.createInternalError(null);
+                        }
+                    }","+                    if (ga * gb > 0) {
+                        final double epsilon = (forward ? 0.25 : -0.25) * convergence;
+                        for (int k = 0; (k < 4) && (ga * gb > 0); ++k) {
+                            ta += epsilon;
+                            interpolator.setInterpolatedTime(ta);
+                            ga = handler.g(ta, interpolator.getInterpolatedState());
+                        }
+                        if (ga * gb > 0) {
+                            throw MathRuntimeException.createInternalError(null);
+                        }
+                    }"
Math 83,junit.framework.AssertionFailedError,"wrapsIfElse
wrongMethodRef","-        int start = getNumObjectiveFunctions();
-      Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset());
-          Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i);","+        int start = ignoreObjectiveRows ? getNumObjectiveFunctions() : 0;
+      Integer negativeVarBasicRow = getBasicRowForSolution(getNegativeDecisionVariableOffset());
+          Integer basicRow = getBasicRowForSolution(getNumObjectiveFunctions() + i);","-        int start = getNumObjectiveFunctions();
+        int start = ignoreObjectiveRows ? getNumObjectiveFunctions() : 0;
-      Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset());
+      Integer negativeVarBasicRow = getBasicRowForSolution(getNegativeDecisionVariableOffset());
-          Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i);
+          Integer basicRow = getBasicRowForSolution(getNumObjectiveFunctions() + i);"
Math 79,java.lang.NullPointerException,notClassified,"-      int sum = 0;
-          final int dp = p1[i] - p2[i];","+      double sum = 0;
+          final double dp = p1[i] - p2[i];","-      int sum = 0;
+      double sum = 0;
-          final int dp = p1[i] - p2[i];
+          final double dp = p1[i] - p2[i];"
Math 85,org.apache.commons.math.MathException,"expLogicMod
singleLine",-        if (fa * fb >= 0.0 ) {,+        if (fa * fb > 0.0 ) {,"-        if (fa * fb >= 0.0 ) {
+        if (fa * fb > 0.0 ) {"
Math 89,java.lang.ClassCastException,wrapsIfElse,,"+        if (v instanceof Comparable<?>){
+        } else {
+            throw new IllegalArgumentException(""Object must implement Comparable"");
+        }","+        if (v instanceof Comparable<?>){
+        } else {
+            throw new IllegalArgumentException(""Object must implement Comparable"");
+        }"
Math 87,junit.framework.AssertionFailedError,"wrapsIfElse
wrongComp","-            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {
-                if (row == null) {
-                } else {
-                }","+            if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {
+            } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {","-            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {
-                if (row == null) {
+            if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {
-                } else {
+            } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {
-                }"
Math 86,junit.framework.AssertionFailedError,codeMove,"-            if (lTData[i][i] < absolutePositivityThreshold) {
-                throw new NotPositiveDefiniteMatrixException();
-            }","+            if (ltI[i] < absolutePositivityThreshold) {
+                throw new NotPositiveDefiniteMatrixException();
+            }","-            if (lTData[i][i] < absolutePositivityThreshold) {
-                throw new NotPositiveDefiniteMatrixException();
-            }
+            if (ltI[i] < absolutePositivityThreshold) {
+                throw new NotPositiveDefiniteMatrixException();
+            }"
Math 88,junit.framework.AssertionFailedError,"blockRemove
condBlockRem
wrapsIfElse
wrongComp","-            if (basicRow != null) {
-                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {
-                    if (tableau.getEntry(basicRow, j) == 1) {
-                         coefficients[i] = 0;
-                    }
-                }","+        Set<Integer> basicRows = new HashSet<Integer>();
+            if (basicRows.contains(basicRow)) {
+                coefficients[i] = 0;
+            } else {
+                basicRows.add(basicRow);","+        Set<Integer> basicRows = new HashSet<Integer>();
+            if (basicRows.contains(basicRow)) {
+                coefficients[i] = 0;
+            } else {
+                basicRows.add(basicRow);
-            if (basicRow != null) {
-                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {
-                    if (tableau.getEntry(basicRow, j) == 1) {
-                         coefficients[i] = 0;
-                    }
-                }"
Math 91,junit.framework.AssertionFailedError,"expArithMod
initFix
wrongComp","-        double nOd = doubleValue();
-        double dOn = object.doubleValue();","+        long nOd = ((long) numerator) * object.denominator;
+        long dOn = ((long) denominator) * object.numerator;","-        double nOd = doubleValue();
-        double dOn = object.doubleValue();
+        long nOd = ((long) numerator) * object.denominator;
+        long dOn = ((long) denominator) * object.numerator;"
Math 93,junit.framework.AssertionFailedError,"condBlockExcAdd
condBlockRetAdd
expLogicMod
missComp
wrongComp","-        long result = Math.round(factorialDouble(n));
-        if (result == Long.MAX_VALUE) {","+        if (n < 0) {
+            throw new IllegalArgumentException(""must have n >= 0 for n!"");
+        }
+        if (n > 20) {
+        if (n < 21) {
+            return factorial(n);
+        }
+        if (n < 21) {
+            return Math.log(factorial(n));
+        }","-        long result = Math.round(factorialDouble(n));
-        if (result == Long.MAX_VALUE) {
+        if (n < 0) {
+            throw new IllegalArgumentException(""must have n >= 0 for n!"");
+        }
+        if (n > 20) {
+        if (n < 21) {
+            return factorial(n);
+        }
+        if (n < 21) {
+            return Math.log(factorial(n));
+        }"
Math 95,java.lang.IllegalArgumentException,"initFix
wrapsIf",-        double ret;,"+        double ret = 1.0;
+        if (d > 2.0) {
+        }","-        double ret;
+        double ret = 1.0;
+        if (d > 2.0) {
+        }"
Math 94,junit.framework.AssertionFailedError,"expLogicMod
singleLine",-        if (u * v == 0) {,+        if ((u == 0) || (v == 0)) {,"-        if (u * v == 0) {
+        if ((u == 0) || (v == 0)) {"
Math 90,java.lang.IllegalArgumentException,notClassified,,"+        addValue((Comparable<?>) v);
+    }
+    public void addValue(Comparable<?>v){","+        addValue((Comparable<?>) v);
+    }
+    public void addValue(Comparable<?>v){"
Math 96,junit.framework.AssertionFailedError,"expLogicMod
singleLine
unwrapMethod",-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); ,+                    ret = (real == rhs.real) && (imaginary == rhs.imaginary); ,"-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); 
+                    ret = (real == rhs.real) && (imaginary == rhs.imaginary); "
Math 92,junit.framework.AssertionFailedError,"blockRemove
condBlockExcAdd
condBlockOthersAdd
condBlockRem
condBlockRetAdd
expArithMod
missComp
wrongMethodRef","-        long result = Math.round(binomialCoefficientDouble(n, k));
-        if (result == Long.MAX_VALUE) {
-            throw new ArithmeticException(
-                ""result too large to represent in a long integer"");
-        }
-        return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);","+        if (k > n / 2)
+            return binomialCoefficient(n, n - k);
+        long result = 1;
+        if (n <= 61) {
+            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
+                result = result * i / j;
+            }
+        } else if (n <= 66) {
+            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
+                long d = gcd(i, j);
+                result = (result / (j / d)) * (i / d);
+            }
+        } else {
+            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
+                long d = gcd(i, j);
+                result = mulAndCheck((result / (j / d)), (i / d));
+            }
+        }
+        if (n < k) {
+            throw new IllegalArgumentException(
+                ""must have n >= k for binomial coefficient (n,k)"");
+        }
+        if (n < 0) {
+            throw new IllegalArgumentException(
+                ""must have n >= 0 for binomial coefficient (n,k)"");
+        }
+        if ((n == k) || (k == 0)) {
+            return 1d;
+        }
+        if ((k == 1) || (k == n - 1)) {
+            return n;
+        }
+        if (k > n/2) {
+            return binomialCoefficientDouble(n, n - k);
+        }
+        if (n < 67) {
+            return binomialCoefficient(n,k);
+        }
+        double result = 1d;
+        for (int i = 1; i <= k; i++) {
+             result *= (double)(n - k + i) / (double)i;
+        }
+        return Math.floor(result + 0.5);
+        if (n < 67) {  
+            return Math.log(binomialCoefficient(n,k));
+        }
+        if (n < 1030) { 
+            return Math.log(binomialCoefficientDouble(n, k));
+        } ","-        long result = Math.round(binomialCoefficientDouble(n, k));
-        if (result == Long.MAX_VALUE) {
-            throw new ArithmeticException(
-                ""result too large to represent in a long integer"");
-        }
+        if (k > n / 2)
+            return binomialCoefficient(n, n - k);
+        long result = 1;
+        if (n <= 61) {
+            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
+                result = result * i / j;
+            }
+        } else if (n <= 66) {
+            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
+                long d = gcd(i, j);
+                result = (result / (j / d)) * (i / d);
+            }
+        } else {
+            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
+                long d = gcd(i, j);
+                result = mulAndCheck((result / (j / d)), (i / d));
+            }
+        }
+        if (n < k) {
+            throw new IllegalArgumentException(
+                ""must have n >= k for binomial coefficient (n,k)"");
+        }
+        if (n < 0) {
+            throw new IllegalArgumentException(
+                ""must have n >= 0 for binomial coefficient (n,k)"");
+        }
+        if ((n == k) || (k == 0)) {
+            return 1d;
+        }
+        if ((k == 1) || (k == n - 1)) {
+            return n;
+        }
+        if (k > n/2) {
+            return binomialCoefficientDouble(n, n - k);
+        }
+        if (n < 67) {
+            return binomialCoefficient(n,k);
+        }
+        double result = 1d;
+        for (int i = 1; i <= k; i++) {
+             result *= (double)(n - k + i) / (double)i;
+        }
-        return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);
+        return Math.floor(result + 0.5);
+        if (n < 67) {  
+            return Math.log(binomialCoefficient(n,k));
+        }
+        if (n < 1030) { 
+            return Math.log(binomialCoefficientDouble(n, k));
+        } "
Math 98,java.lang.ArrayIndexOutOfBoundsException,"copyPaste
initFix
wrongVarRef","-        final BigDecimal[] out = new BigDecimal[v.length];
-        final double[] out = new double[v.length];","+        final BigDecimal[] out = new BigDecimal[nRows];
+        final double[] out = new double[nRows];","-        final BigDecimal[] out = new BigDecimal[v.length];
+        final BigDecimal[] out = new BigDecimal[nRows];
-        final double[] out = new double[v.length];
+        final double[] out = new double[nRows];"
Math 101,java.lang.StringIndexOutOfBoundsException,"expLogicExpand
singleLine",-        if (,"+        if ((startIndex >= source.length()) ||
+            (endIndex > source.length()) ||","-        if (
+        if ((startIndex >= source.length()) ||
+            (endIndex > source.length()) ||"
Math 105,junit.framework.AssertionFailedError,"singleLine
wrapsMethod",-        return sumYY - sumXY * sumXY / sumXX;,"+        return Math.max(0d, sumYY - sumXY * sumXY / sumXX);","-        return sumYY - sumXY * sumXY / sumXX;
+        return Math.max(0d, sumYY - sumXY * sumXY / sumXX);"
Math 104,junit.framework.AssertionFailedError,"constChange
initFix
singleLine",-    private static final double DEFAULT_EPSILON = 10e-9;,+    private static final double DEFAULT_EPSILON = 10e-15;,"-    private static final double DEFAULT_EPSILON = 10e-9;
+    private static final double DEFAULT_EPSILON = 10e-15;"
Math 97,java.lang.IllegalArgumentException,"condBlockOthersAdd
expLogicMod
wrapsIfElse","-        if (sign >= 0) {
-        } else {","+        if (sign > 0) {
+            if (Math.abs(yMin) <= functionValueAccuracy) {
+                setResult(min, 0);
+                ret = min;
+            } else if (Math.abs(yMax) <= functionValueAccuracy) {
+                setResult(max, 0);
+                ret = max;
+            } else {
+            }
+        } else if (sign < 0){
+        } else {
+            if (yMin == 0.0) {
+                ret = min;
+            } else {
+                ret = max;
+            }","-        if (sign >= 0) {
+        if (sign > 0) {
+            if (Math.abs(yMin) <= functionValueAccuracy) {
+                setResult(min, 0);
+                ret = min;
+            } else if (Math.abs(yMax) <= functionValueAccuracy) {
+                setResult(max, 0);
+                ret = max;
+            } else {
-        } else {
+            }
+        } else if (sign < 0){
+        } else {
+            if (yMin == 0.0) {
+                ret = min;
+            } else {
+                ret = max;
+            }"
Math 100,java.lang.ArrayIndexOutOfBoundsException,"copyPaste
wrongMethodRef","-        final int cols = problem.getAllParameters().length;
-        int p = problem.getAllParameters().length;
-        double[] errors = new double[problem.getAllParameters().length];","+        final int cols = problem.getUnboundParameters().length;
+        int p = problem.getUnboundParameters().length;
+        double[] errors = new double[problem.getUnboundParameters().length];","-        final int cols = problem.getAllParameters().length;
+        final int cols = problem.getUnboundParameters().length;
-        int p = problem.getAllParameters().length;
+        int p = problem.getUnboundParameters().length;
-        double[] errors = new double[problem.getAllParameters().length];
+        double[] errors = new double[problem.getUnboundParameters().length];"
Math 103,org.apache.commons.math.MaxIterationsExceededException,"condBlockExcAdd
condBlockRetAdd
wrapsTryCatch
wrongComp",,"+        try {
+        } catch (MaxIterationsExceededException ex) {
+            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38
+                return 0.0d;
+            } else if (x > (mean + 20 * standardDeviation)) {
+                return 1.0d;
+            } else {
+                throw ex;
+            }
+        }","+        try {
+        } catch (MaxIterationsExceededException ex) {
+            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38
+                return 0.0d;
+            } else if (x > (mean + 20 * standardDeviation)) {
+                return 1.0d;
+            } else {
+                throw ex;
+            }
+        }"
Math 102,junit.framework.AssertionFailedError,"condBlockOthersAdd
missComp
wrapsIfElse",,"+        double sumExpected = 0d;
+        double sumObserved = 0d;
+        for (int i = 0; i < observed.length; i++) {
+            sumExpected += expected[i];
+            sumObserved += observed[i];
+        }
+        double ratio = 1.0d;
+        boolean rescale = false;
+        if (Math.abs(sumExpected - sumObserved) > 10E-6) {
+            ratio = sumObserved / sumExpected;
+            rescale = true;
+        }
+            if (rescale) {
+                dev = ((double) observed[i] - ratio * expected[i]);
+                sumSq += dev * dev / (ratio * expected[i]);
+            } else {
+            }","+        double sumExpected = 0d;
+        double sumObserved = 0d;
+        for (int i = 0; i < observed.length; i++) {
+            sumExpected += expected[i];
+            sumObserved += observed[i];
+        }
+        double ratio = 1.0d;
+        boolean rescale = false;
+        if (Math.abs(sumExpected - sumObserved) > 10E-6) {
+            ratio = sumObserved / sumExpected;
+            rescale = true;
+        }
+            if (rescale) {
+                dev = ((double) observed[i] - ratio * expected[i]);
+                sumSq += dev * dev / (ratio * expected[i]);
+            } else {
+            }"
Math 99,junit.framework.AssertionFailedError,condBlockExcAdd,,"+            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {
+                throw MathRuntimeException.createArithmeticException(
+                        ""overflow: gcd({0}, {1}) is 2^31"",
+                        new Object[] { p, q });
+            }
+        if (lcm == Integer.MIN_VALUE){
+            throw new ArithmeticException(""overflow: lcm is 2^31"");
+        }","+            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {
+                throw MathRuntimeException.createArithmeticException(
+                        ""overflow: gcd({0}, {1}) is 2^31"",
+                        new Object[] { p, q });
+            }
+        if (lcm == Integer.MIN_VALUE){
+            throw new ArithmeticException(""overflow: lcm is 2^31"");
+        }"
Math 106,junit.framework.AssertionFailedError,"condBlockRetAdd
copyPaste",,"+        if (num.intValue() < 0) {
+            pos.setIndex(initialIndex);
+            return null;
+        }
+        if (den.intValue() < 0) {
+            pos.setIndex(initialIndex);
+            return null;
+        }","+        if (num.intValue() < 0) {
+            pos.setIndex(initialIndex);
+            return null;
+        }
+        if (den.intValue() < 0) {
+            pos.setIndex(initialIndex);
+            return null;
+        }"
Mockito 3,junit.framework.AssertionFailedError,"condBlockOthersAdd
wrongComp","-            for (int position = indexOfVararg; position < matchers.size(); position++) {
-                Matcher m = matchers.get(position);
-                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);","+            for (Matcher m : uniqueMatcherSet(indexOfVararg)) {
+                    Object rawArgument = invocation.getRawArguments()[indexOfVararg];
+                    for (int i = 0; i < Array.getLength(rawArgument); i++) {
+                        ((CapturesArguments) m).captureFrom(Array.get(rawArgument, i));
+                    }
+    private Set<Matcher> uniqueMatcherSet(int indexOfVararg) {
+        HashSet<Matcher> set = new HashSet<Matcher>();
+        for (int position = indexOfVararg; position < matchers.size(); position++) {
+            Matcher matcher = matchers.get(position);
+            if(matcher instanceof MatcherDecorator) {
+                set.add(((MatcherDecorator) matcher).getActualMatcher());
+            } else {
+                set.add(matcher);
+            }
+        }
+        return set;
+    }","-            for (int position = indexOfVararg; position < matchers.size(); position++) {
-                Matcher m = matchers.get(position);
+            for (Matcher m : uniqueMatcherSet(indexOfVararg)) {
-                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);
+                    Object rawArgument = invocation.getRawArguments()[indexOfVararg];
+                    for (int i = 0; i < Array.getLength(rawArgument); i++) {
+                        ((CapturesArguments) m).captureFrom(Array.get(rawArgument, i));
+                    }
+    private Set<Matcher> uniqueMatcherSet(int indexOfVararg) {
+        HashSet<Matcher> set = new HashSet<Matcher>();
+        for (int position = indexOfVararg; position < matchers.size(); position++) {
+            Matcher matcher = matchers.get(position);
+            if(matcher instanceof MatcherDecorator) {
+                set.add(((MatcherDecorator) matcher).getActualMatcher());
+            } else {
+                set.add(matcher);
+            }
+        }
+        return set;
+    }"
Mockito 2,junit.framework.AssertionFailedError,"condBlockOthersAdd
missComp",,"+        validateInput(durationMillis);
+    private void validateInput(long durationMillis) {
+        if (durationMillis < 0) {
+            new Reporter().cannotCreateTimerWithNegativeDurationTime(durationMillis);
+        }
+    }","+        validateInput(durationMillis);
+    private void validateInput(long durationMillis) {
+        if (durationMillis < 0) {
+            new Reporter().cannotCreateTimerWithNegativeDurationTime(durationMillis);
+        }
+    }"
Mockito 1,java.lang.UnsupportedOperationException,"condBlockOthersAdd
missComp",-            throw new UnsupportedOperationException();,"+            for (int position = 0; position < indexOfVararg; position++) {
+                Matcher m = matchers.get(position);
+                if (m instanceof CapturesArguments) {
+                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));
+                }
+            }
+            for (int position = indexOfVararg; position < matchers.size(); position++) {
+                Matcher m = matchers.get(position);
+                if (m instanceof CapturesArguments) {
+                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);
+                }
+            }","-            throw new UnsupportedOperationException();
+            for (int position = 0; position < indexOfVararg; position++) {
+                Matcher m = matchers.get(position);
+                if (m instanceof CapturesArguments) {
+                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));
+                }
+            }
+            for (int position = indexOfVararg; position < matchers.size(); position++) {
+                Matcher m = matchers.get(position);
+                if (m instanceof CapturesArguments) {
+                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);
+                }
+            }"
Mockito 7,org.mockito.exceptions.base.MockitoException,"missComp
singleLine",,"+            registerTypeParametersOn(new TypeVariable[] { typeVariable });","+            registerTypeParametersOn(new TypeVariable[] { typeVariable });"
Mockito 4,java.lang.Exception,"condBlockRetAdd
copyPaste
missNullCheckP
wrapsMethod","-                ""But found this interaction on mock '"" + undesired.getMock() + ""':"",
-                ""But found this interaction on mock '"" + undesired.getMock() + ""':"",","+                ""But found this interaction on mock '"" + safelyGetMockName(undesired.getMock()) + ""':"",
+                ""But found this interaction on mock '"" + safelyGetMockName(undesired.getMock()) + ""':"",
+        if (details.getCause() == null) {
+            return details.getMessage();
+        }","-                ""But found this interaction on mock '"" + undesired.getMock() + ""':"",
+                ""But found this interaction on mock '"" + safelyGetMockName(undesired.getMock()) + ""':"",
-                ""But found this interaction on mock '"" + undesired.getMock() + ""':"",
+                ""But found this interaction on mock '"" + safelyGetMockName(undesired.getMock()) + ""':"",
+        if (details.getCause() == null) {
+            return details.getMessage();
+        }"
Mockito 11,junit.framework.AssertionFailedError,"condBlockRetAdd
wrapsIfElse",-        return 1;,"+        if (this == o) {
+            return true;
+        }
+        if (o instanceof DelegatingMethod) {
+            DelegatingMethod that = (DelegatingMethod) o;
+            return method.equals(that.method);
+        } else {
+        }
+        return method.hashCode();","+        if (this == o) {
+            return true;
+        }
+        if (o instanceof DelegatingMethod) {
+            DelegatingMethod that = (DelegatingMethod) o;
+            return method.equals(that.method);
+        } else {
+        }
-        return 1;
+        return method.hashCode();"
Mockito 10,org.mockito.exceptions.base.MockitoException,"missComp
notClassified","-                newDeepStubMock(returnTypeGenericMetadata),
-    private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {
-                withSettingsUsing(returnTypeGenericMetadata)
-    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {
-        return mockSettings.serializable()","+                newDeepStubMock(returnTypeGenericMetadata, invocation.getMock()),
+    private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata, Object parentMock) {
+        MockCreationSettings parentMockSettings = new MockUtil().getMockSettings(parentMock);
+                withSettingsUsing(returnTypeGenericMetadata, parentMockSettings)
+    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata, MockCreationSettings parentMockSettings) {
+        return propagateSerializationSettings(mockSettings, parentMockSettings)
+    private MockSettings propagateSerializationSettings(MockSettings mockSettings, MockCreationSettings parentMockSettings) {
+        return mockSettings.serializable(parentMockSettings.getSerializableMode());
+    }","-                newDeepStubMock(returnTypeGenericMetadata),
+                newDeepStubMock(returnTypeGenericMetadata, invocation.getMock()),
-    private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {
+    private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata, Object parentMock) {
+        MockCreationSettings parentMockSettings = new MockUtil().getMockSettings(parentMock);
-                withSettingsUsing(returnTypeGenericMetadata)
+                withSettingsUsing(returnTypeGenericMetadata, parentMockSettings)
-    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {
+    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata, MockCreationSettings parentMockSettings) {
-        return mockSettings.serializable()
+        return propagateSerializationSettings(mockSettings, parentMockSettings)
+    private MockSettings propagateSerializationSettings(MockSettings mockSettings, MockCreationSettings parentMockSettings) {
+        return mockSettings.serializable(parentMockSettings.getSerializableMode());
+    }"
Mockito 5,junit.framework.AssertionFailedError,singleLine,-            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {,+            catch (AssertionError e) {,"-            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {
+            catch (AssertionError e) {"
Mockito 6,junit.framework.ComparisonFailure,"copyPaste
wrongMethodRef
wrongVarRef","-        return reportMatcher(Any.ANY).returnFalse();
-        return reportMatcher(Any.ANY).returnZero();
-        return reportMatcher(Any.ANY).returnChar();
-        return reportMatcher(Any.ANY).returnZero();
-        return reportMatcher(Any.ANY).returnZero();
-        return reportMatcher(Any.ANY).returnZero();
-        return reportMatcher(Any.ANY).returnZero();
-        return reportMatcher(Any.ANY).returnZero();
-        return (T) reportMatcher(Any.ANY).returnNull();
-        return (T) reportMatcher(Any.ANY).returnFor(clazz);
-        return (T) anyObject();
-        return reportMatcher(Any.ANY).returnString();
-        return reportMatcher(Any.ANY).returnList();
-        return (List) reportMatcher(Any.ANY).returnList();
-        return reportMatcher(Any.ANY).returnSet();
-        return (Set) reportMatcher(Any.ANY).returnSet();
-        return reportMatcher(Any.ANY).returnMap();
-        return reportMatcher(Any.ANY).returnMap();
-        return reportMatcher(Any.ANY).returnList();
-        return (Collection) reportMatcher(Any.ANY).returnList();","+        return reportMatcher(new InstanceOf(Boolean.class)).returnFalse();
+        return reportMatcher(new InstanceOf(Byte.class)).returnZero();
+        return reportMatcher(new InstanceOf(Character.class)).returnChar();
+        return reportMatcher(new InstanceOf(Integer.class)).returnZero();
+        return reportMatcher(new InstanceOf(Long.class)).returnZero();
+        return reportMatcher(new InstanceOf(Float.class)).returnZero();
+        return reportMatcher(new InstanceOf(Double.class)).returnZero();
+        return reportMatcher(new InstanceOf(Short.class)).returnZero();
+        return (T) reportMatcher(new InstanceOf(Object.class)).returnNull();
+        return (T) reportMatcher(new InstanceOf(clazz)).returnFor(clazz);
+        return (T) reportMatcher(Any.ANY).returnNull();
+        return reportMatcher(new InstanceOf(String.class)).returnString();
+        return reportMatcher(new InstanceOf(List.class)).returnList();
+        return anyList();
+        return reportMatcher(new InstanceOf(Set.class)).returnSet();
+        return anySet();
+        return reportMatcher(new InstanceOf(Map.class)).returnMap();
+        return anyMap();
+        return reportMatcher(new InstanceOf(Collection.class)).returnList();
+        return anyCollection();","-        return reportMatcher(Any.ANY).returnFalse();
+        return reportMatcher(new InstanceOf(Boolean.class)).returnFalse();
-        return reportMatcher(Any.ANY).returnZero();
+        return reportMatcher(new InstanceOf(Byte.class)).returnZero();
-        return reportMatcher(Any.ANY).returnChar();
+        return reportMatcher(new InstanceOf(Character.class)).returnChar();
-        return reportMatcher(Any.ANY).returnZero();
+        return reportMatcher(new InstanceOf(Integer.class)).returnZero();
-        return reportMatcher(Any.ANY).returnZero();
+        return reportMatcher(new InstanceOf(Long.class)).returnZero();
-        return reportMatcher(Any.ANY).returnZero();
+        return reportMatcher(new InstanceOf(Float.class)).returnZero();
-        return reportMatcher(Any.ANY).returnZero();
+        return reportMatcher(new InstanceOf(Double.class)).returnZero();
-        return reportMatcher(Any.ANY).returnZero();
+        return reportMatcher(new InstanceOf(Short.class)).returnZero();
-        return (T) reportMatcher(Any.ANY).returnNull();
+        return (T) reportMatcher(new InstanceOf(Object.class)).returnNull();
-        return (T) reportMatcher(Any.ANY).returnFor(clazz);
+        return (T) reportMatcher(new InstanceOf(clazz)).returnFor(clazz);
-        return (T) anyObject();
+        return (T) reportMatcher(Any.ANY).returnNull();
-        return reportMatcher(Any.ANY).returnString();
+        return reportMatcher(new InstanceOf(String.class)).returnString();
-        return reportMatcher(Any.ANY).returnList();
+        return reportMatcher(new InstanceOf(List.class)).returnList();
-        return (List) reportMatcher(Any.ANY).returnList();
+        return anyList();
-        return reportMatcher(Any.ANY).returnSet();
+        return reportMatcher(new InstanceOf(Set.class)).returnSet();
-        return (Set) reportMatcher(Any.ANY).returnSet();
+        return anySet();
-        return reportMatcher(Any.ANY).returnMap();
+        return reportMatcher(new InstanceOf(Map.class)).returnMap();
-        return reportMatcher(Any.ANY).returnMap();
+        return anyMap();
-        return reportMatcher(Any.ANY).returnList();
+        return reportMatcher(new InstanceOf(Collection.class)).returnList();
-        return (Collection) reportMatcher(Any.ANY).returnList();
+        return anyCollection();"
Mockito 9,org.mockito.exceptions.base.MockitoException,condBlockRetAdd,,"+    	if (Modifier.isAbstract(invocation.getMethod().getModifiers())) {
+    		return new GloballyConfiguredAnswer().answer(invocation);
+    	}","+    	if (Modifier.isAbstract(invocation.getMethod().getModifiers())) {
+    		return new GloballyConfiguredAnswer().answer(invocation);
+    	}"
Mockito 8,java.lang.StackOverflowError,"singleLine
wrapsIf","-            } else {","+            } else if (typeParameter != actualTypeArgument) {","-            } else {
+            } else if (typeParameter != actualTypeArgument) {"
Mockito 16,org.mockito.exceptions.misusing.MissingMethodInvocationException,wrapsIf,"-        return MOCKITO_CORE.mock(classToMock, mockSettings);
-                .defaultAnswer(CALLS_REAL_METHODS)); 
-    public <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing) { return mock(classToMock, mockSettings); }
-    public <T> T mock(Class<T> classToMock, MockSettings mockSettings) {","+        return MOCKITO_CORE.mock(classToMock, mockSettings, true);
+                .defaultAnswer(CALLS_REAL_METHODS), true); 
+    public <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing) {
+        if (shouldResetOngoingStubbing) {
+        }","-        return MOCKITO_CORE.mock(classToMock, mockSettings);
+        return MOCKITO_CORE.mock(classToMock, mockSettings, true);
-                .defaultAnswer(CALLS_REAL_METHODS)); 
+                .defaultAnswer(CALLS_REAL_METHODS), true); 
-    public <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing) { return mock(classToMock, mockSettings); }
-    public <T> T mock(Class<T> classToMock, MockSettings mockSettings) {
+    public <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing) {
+        if (shouldResetOngoingStubbing) {
+        }"
Mockito 15,junit.framework.AssertionFailedError,wrapsIf,,"+                        if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) {
+                        }","+                        if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) {
+                        }"
Mockito 14,junit.framework.AssertionFailedError,"wrapsIf
wrapsMethod","-        mockingProgress.verificationStarted(mode);","+            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {
+            }
+        mockingProgress.verificationStarted(new MockAwareVerificationMode(mock, mode));","+            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {
+            }
-        mockingProgress.verificationStarted(mode);
+        mockingProgress.verificationStarted(new MockAwareVerificationMode(mock, mode));"
Mockito 12,java.lang.ClassCastException,wrapsIfElse,,"+            if (actual instanceof Class) {
+            } else if (actual instanceof ParameterizedType) {
+                return (Class) ((ParameterizedType) actual).getRawType();
+            }","+            if (actual instanceof Class) {
+            } else if (actual instanceof ParameterizedType) {
+                return (Class) ((ParameterizedType) actual).getRawType();
+            }"
Mockito 13,junit.framework.AssertionFailedError,"condBlockOthersAdd
expLogicReduce","-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                ","+            if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                
+            } else {
+                mockingProgress.verificationStarted(verificationMode);","-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                
+            if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                
+            } else {
+                mockingProgress.verificationStarted(verificationMode);"
Mockito 17,java.io.NotSerializableException,"expLogicMod
wrapsIfElse","-        return this.extraInterfaces(java.io.Serializable.class);
-        return extraInterfaces != null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);","+    private boolean serializable;
+        this.serializable = true;
+        return this;
+        return serializable;
+        if (settings.isSerializable()) {
+            ancillaryTypes = interfaces == null ? new Class<?>[] {Serializable.class} : new ArrayUtils().concat(interfaces, Serializable.class);
+        } else {
+        }","+    private boolean serializable;
-        return this.extraInterfaces(java.io.Serializable.class);
+        this.serializable = true;
+        return this;
-        return extraInterfaces != null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);
+        return serializable;
+        if (settings.isSerializable()) {
+            ancillaryTypes = interfaces == null ? new Class<?>[] {Serializable.class} : new ArrayUtils().concat(interfaces, Serializable.class);
+        } else {
+        }"
Mockito 18,java.lang.NullPointerException,condBlockRetAdd,,"+        } else if (type == Iterable.class) {
+            return new ArrayList<Object>(0);","+        } else if (type == Iterable.class) {
+            return new ArrayList<Object>(0);"
Mockito 22,java.lang.RuntimeException,condBlockRetAdd,"-        if (o1 == null || o2 == null) {","+        if (o1 == o2 ) {
+            return true;","-        if (o1 == null || o2 == null) {
+        if (o1 == o2 ) {
+            return true;"
Mockito 20,junit.framework.ComparisonFailure,wrongVarRef,"-            mockInstance = classInstantiator.instantiate(mockedProxyType);
-                    ""  instance creation by : "" + classInstantiator.getClass().getSimpleName(),","+        Instantiator instantiator = new InstantiatorProvider().getInstantiator(settings);
+            mockInstance = instantiator.newInstance(mockedProxyType);
+                    ""  instance creation by : "" + instantiator.getClass().getSimpleName(),","+        Instantiator instantiator = new InstantiatorProvider().getInstantiator(settings);
-            mockInstance = classInstantiator.instantiate(mockedProxyType);
+            mockInstance = instantiator.newInstance(mockedProxyType);
-                    ""  instance creation by : "" + classInstantiator.getClass().getSimpleName(),
+                    ""  instance creation by : "" + instantiator.getClass().getSimpleName(),"
Mockito 19,junit.framework.AssertionFailedError,"condBlockOthersAdd
condBlockRetAdd","-            Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject();
-    public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {
-            Object fieldInstance
-    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {
-        return next.filterCandidate(mockTypeMatches, field, fieldInstance);","+            Object injected = mockCandidateFilter.filterCandidate(mocks, field, orderedInstanceFields, instance).thenInject();
+    public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, List<Field> fields, final Object fieldInstance) {
+            List<Field> fields, Object instance
+    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, List<Field> fields, Object fieldInstance) {
+        return next.filterCandidate(mockTypeMatches, field, fields, fieldInstance);","-            Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject();
+            Object injected = mockCandidateFilter.filterCandidate(mocks, field, orderedInstanceFields, instance).thenInject();
-    public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {
+    public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, List<Field> fields, final Object fieldInstance) {
-            Object fieldInstance
+            List<Field> fields, Object instance
-    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {
+    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, List<Field> fields, Object fieldInstance) {
-        return next.filterCandidate(mockTypeMatches, field, fieldInstance);
+        return next.filterCandidate(mockTypeMatches, field, fields, fieldInstance);"
Mockito 21,org.mockito.internal.creation.instance.InstantationException,"condBlockOthersAdd
condBlockRetAdd
wrongComp","-        return withOuterClass(cls);
-    private <T> T withOuterClass(Class<T> cls) {
-            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());
-            return c.newInstance(outerClassInstance);","+        return withParams(cls, outerClassInstance);
+    private static <T> T withParams(Class<T> cls, Object... params) {
+            for (Constructor<?> constructor : cls.getDeclaredConstructors()) {
+                Class<?>[] types = constructor.getParameterTypes();
+                if (paramsMatch(types, params)) {
+                    return (T) constructor.newInstance(params);
+                }
+            }
+        throw paramsException(cls, null);
+    private static boolean paramsMatch(Class<?>[] types, Object[] params) {
+        if (params.length != types.length) {
+            return false;
+        }
+        for (int i = 0; i < params.length; i++) {
+            if (!types[i].isInstance(params[i])) {
+                return false;
+            }
+        }
+        return true;
+    }","-        return withOuterClass(cls);
+        return withParams(cls, outerClassInstance);
-    private <T> T withOuterClass(Class<T> cls) {
+    private static <T> T withParams(Class<T> cls, Object... params) {
-            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());
-            return c.newInstance(outerClassInstance);
+            for (Constructor<?> constructor : cls.getDeclaredConstructors()) {
+                Class<?>[] types = constructor.getParameterTypes();
+                if (paramsMatch(types, params)) {
+                    return (T) constructor.newInstance(params);
+                }
+            }
+        throw paramsException(cls, null);
+    private static boolean paramsMatch(Class<?>[] types, Object[] params) {
+        if (params.length != types.length) {
+            return false;
+        }
+        for (int i = 0; i < params.length; i++) {
+            if (!types[i].isInstance(params[i])) {
+                return false;
+            }
+        }
+        return true;
+    }"
Mockito 23,java.io.NotSerializableException,"condBlockOthersAdd
missNullCheckP","-    private MockitoCore mockitoCore = new MockitoCore();
-    private ReturnsEmptyValues delegate = new ReturnsEmptyValues();
-        container.addAnswer(new Answer<Object>() {","+    private transient MockitoCore mockitoCore;
+    private transient ReturnsEmptyValues delegate;
+        instantiateMockitoCoreIfNeeded();
+        instantiateDelegateIfNeeded();
+    private synchronized void instantiateMockitoCoreIfNeeded() {
+        if (mockitoCore == null) {
+            mockitoCore = new MockitoCore();
+        }
+    }
+    private synchronized void instantiateDelegateIfNeeded() {
+        if (delegate == null) {
+            delegate = new ReturnsEmptyValues();
+        }
+    }
+        container.addAnswer(new SerializableAnswer() {","-    private MockitoCore mockitoCore = new MockitoCore();
-    private ReturnsEmptyValues delegate = new ReturnsEmptyValues();
+    private transient MockitoCore mockitoCore;
+    private transient ReturnsEmptyValues delegate;
+        instantiateMockitoCoreIfNeeded();
+        instantiateDelegateIfNeeded();
+    private synchronized void instantiateMockitoCoreIfNeeded() {
+        if (mockitoCore == null) {
+            mockitoCore = new MockitoCore();
+        }
+    }
+    private synchronized void instantiateDelegateIfNeeded() {
+        if (delegate == null) {
+            delegate = new ReturnsEmptyValues();
+        }
+    }
-        container.addAnswer(new Answer<Object>() {
+        container.addAnswer(new SerializableAnswer() {"
Mockito 28,junit.framework.AssertionFailedError,"missComp
singleLine
wrapsMethod","-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();","+            Object injected = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();
+            mocks.remove(injected);","-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();
+            Object injected = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();
+            mocks.remove(injected);"
Mockito 24,junit.framework.AssertionFailedError,"singleLine
wrapsIfElse",-            return 1;,+            return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;,"-            return 1;
+            return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;"
Mockito 29,java.lang.Exception,"missNullCheckP
singleLine
wrapsIfElse",-        description.appendText(wanted.toString());,"+        description.appendText(wanted == null ? ""null"" : wanted.toString());","-        description.appendText(wanted.toString());
+        description.appendText(wanted == null ? ""null"" : wanted.toString());"
Mockito 25,java.lang.ClassCastException,"missComp
notClassified","-        return getMock(invocation);
-    private Object getMock(InvocationOnMock invocation) throws Throwable {
-        return recordDeepStubMock(invocation, container);
-    private Object recordDeepStubMock(InvocationOnMock invocation, InvocationContainerImpl container) {
-        Class<?> clz = invocation.getMethod().getReturnType();
-        final Object mock = org.mockito.Mockito.mock(clz, this);","+        return getMock(invocation, returnTypeGenericMetadata);
+    private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {
+        return recordDeepStubMock(createNewDeepStubMock(returnTypeGenericMetadata), container);
+    private Object createNewDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {
+        return mock(
+                returnTypeGenericMetadata.rawType(),
+                withSettingsUsing(returnTypeGenericMetadata)
+        );
+    }
+    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {
+        MockSettings mockSettings =
+                returnTypeGenericMetadata.rawExtraInterfaces().length > 0 ?
+                withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())
+                : withSettings();
+        return mockSettings
+                .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));
+    }
+    private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {
+        return new ReturnsDeepStubs() {
+            @Override
+            protected GenericMetadataSupport actualParameterizedType(Object mock) {
+                return returnTypeGenericMetadata;
+            }
+        };
+    }
+    private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {","-        return getMock(invocation);
+        return getMock(invocation, returnTypeGenericMetadata);
-    private Object getMock(InvocationOnMock invocation) throws Throwable {
+    private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {
-        return recordDeepStubMock(invocation, container);
+        return recordDeepStubMock(createNewDeepStubMock(returnTypeGenericMetadata), container);
+    private Object createNewDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {
+        return mock(
+                returnTypeGenericMetadata.rawType(),
+                withSettingsUsing(returnTypeGenericMetadata)
+        );
+    }
+    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {
+        MockSettings mockSettings =
+                returnTypeGenericMetadata.rawExtraInterfaces().length > 0 ?
+                withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())
+                : withSettings();
+        return mockSettings
+                .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));
+    }
+    private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {
+        return new ReturnsDeepStubs() {
+            @Override
+            protected GenericMetadataSupport actualParameterizedType(Object mock) {
+                return returnTypeGenericMetadata;
+            }
+        };
+    }
-    private Object recordDeepStubMock(InvocationOnMock invocation, InvocationContainerImpl container) {
-        Class<?> clz = invocation.getMethod().getReturnType();
-        final Object mock = org.mockito.Mockito.mock(clz, this);
+    private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {"
Mockito 27,junit.framework.AssertionFailedError,"initFix
notClassified","-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);
-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));","+        MethodInterceptorFilter newFilter = newMethodInterceptorFilter(oldMockHandler.getMockSettings());","-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);
-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));
+        MethodInterceptorFilter newFilter = newMethodInterceptorFilter(oldMockHandler.getMockSettings());"
Mockito 26,java.lang.ClassCastException,"constChange
singleLine
wrongComp","-        primitiveValues.put(double.class, 0);","+        primitiveValues.put(double.class, 0D);","-        primitiveValues.put(double.class, 0);
+        primitiveValues.put(double.class, 0D);"
Mockito 32,junit.framework.AssertionFailedError,"missComp
wrongMethodRef","-                        field.set(testClass, Mockito.spy(instance));","+                        field.set(testClass, Mockito.mock(instance.getClass(), withSettings()
+                                .spiedInstance(instance)
+                                .defaultAnswer(Mockito.CALLS_REAL_METHODS)
+                                .name(field.getName())));","-                        field.set(testClass, Mockito.spy(instance));
+                        field.set(testClass, Mockito.mock(instance.getClass(), withSettings()
+                                .spiedInstance(instance)
+                                .defaultAnswer(Mockito.CALLS_REAL_METHODS)
+                                .name(field.getName())));"
Mockito 31,junit.framework.ComparisonFailure,"missComp
notClassified",,,
Mockito 34,java.lang.ArrayIndexOutOfBoundsException,"expLogicExpand
singleLine",-            if (m instanceof CapturesArguments) {,+            if (m instanceof CapturesArguments && i.getArguments().length > k) {,"-            if (m instanceof CapturesArguments) {
+            if (m instanceof CapturesArguments && i.getArguments().length > k) {"
Mockito 36,java.lang.NullPointerException,condBlockOthersAdd,,"+        if (this.getMethod().getDeclaringClass().isInterface()) {
+            new Reporter().cannotCallRealMethodOnInterface();
+        }","+        if (this.getMethod().getDeclaringClass().isInterface()) {
+            new Reporter().cannotCallRealMethodOnInterface();
+        }"
Mockito 33,junit.framework.AssertionFailedError,"condBlockOthersAdd
condBlockRetAdd
missNullCheckN
wrongComp",-        return m1.equals(m2);,"+        if (m1.getName() != null && m1.getName().equals(m2.getName())) {
+        	Class[] params1 = m1.getParameterTypes();
+        	Class[] params2 = m2.getParameterTypes();
+        	if (params1.length == params2.length) {
+        	    for (int i = 0; i < params1.length; i++) {
+        		if (params1[i] != params2[i])
+        		    return false;
+        	    }
+        	    return true;
+        	}
+        }
+        return false;","+        if (m1.getName() != null && m1.getName().equals(m2.getName())) {
-        return m1.equals(m2);
+        	Class[] params1 = m1.getParameterTypes();
+        	Class[] params2 = m2.getParameterTypes();
+        	if (params1.length == params2.length) {
+        	    for (int i = 0; i < params1.length; i++) {
+        		if (params1[i] != params2[i])
+        		    return false;
+        	    }
+        	    return true;
+        	}
+        }
+        return false;"
Mockito 35,java.lang.NullPointerException,"copyPaste
wrongMethodRef","-        return reportMatcher(new InstanceOf(clazz)).<T>returnNull();
-        return reportMatcher(new Equals(value)).<T>returnNull();
-        return reportMatcher(new Same(value)).<T>returnNull();","+        return reportMatcher(new InstanceOf(clazz)).<T>returnFor(clazz);
+        return (T) reportMatcher(new Equals(value)).<T>returnFor((Class) value.getClass());
+        return (T) reportMatcher(new Same(value)).<T>returnFor((Class) value.getClass());","-        return reportMatcher(new InstanceOf(clazz)).<T>returnNull();
+        return reportMatcher(new InstanceOf(clazz)).<T>returnFor(clazz);
-        return reportMatcher(new Equals(value)).<T>returnNull();
+        return (T) reportMatcher(new Equals(value)).<T>returnFor((Class) value.getClass());
-        return reportMatcher(new Same(value)).<T>returnNull();
+        return (T) reportMatcher(new Same(value)).<T>returnFor((Class) value.getClass());"
Mockito 30,junit.framework.AssertionFailedError,"initFix
notClassified","-    public void smartNullPointerException(Location location) {
-            new Reporter().smartNullPointerException(location);","+    public void smartNullPointerException(Object obj, Location location) {
+                obj,
+            new Reporter().smartNullPointerException(obj, location);","-    public void smartNullPointerException(Location location) {
+    public void smartNullPointerException(Object obj, Location location) {
+                obj,
-            new Reporter().smartNullPointerException(location);
+            new Reporter().smartNullPointerException(obj, location);"
Mockito 38,java.lang.NullPointerException,"missNullCheckP
singleLine
wrapsIfElse","-        return StringDescription.toString(m).equals(arg.toString());","+        return StringDescription.toString(m).equals(arg == null? ""null"" : arg.toString());","-        return StringDescription.toString(m).equals(arg.toString());
+        return StringDescription.toString(m).equals(arg == null? ""null"" : arg.toString());"
Time 5,java.lang.UnsupportedOperationException,"blockRemove
condBlockExcAdd
expLogicMod
wrongVarRef","-            years = FieldUtils.safeAdd(years, months / 12);
-            months = months % 12;
-            if (years != 0) {
-                result = result.withYears(years);
-            if (months != 0) {
-                result = result.withMonths(months);","+            long totalMonths = years * 12L + months;
+            if (type.isSupported(DurationFieldType.YEARS_TYPE)) {
+                int normalizedYears = FieldUtils.safeToInt(totalMonths / 12);
+                result = result.withYears(normalizedYears);
+                totalMonths = totalMonths - (normalizedYears * 12);
+            if (type.isSupported(DurationFieldType.MONTHS_TYPE)) {
+                int normalizedMonths = FieldUtils.safeToInt(totalMonths);
+                result = result.withMonths(normalizedMonths);
+                totalMonths = totalMonths - normalizedMonths;
+            }
+            if (totalMonths != 0) {
+                throw new UnsupportedOperationException(""Unable to normalize as PeriodType is missing either years or months but period has a month/year amount: "" + toString());","-            years = FieldUtils.safeAdd(years, months / 12);
-            months = months % 12;
-            if (years != 0) {
-                result = result.withYears(years);
+            long totalMonths = years * 12L + months;
+            if (type.isSupported(DurationFieldType.YEARS_TYPE)) {
+                int normalizedYears = FieldUtils.safeToInt(totalMonths / 12);
+                result = result.withYears(normalizedYears);
+                totalMonths = totalMonths - (normalizedYears * 12);
-            if (months != 0) {
-                result = result.withMonths(months);
+            if (type.isSupported(DurationFieldType.MONTHS_TYPE)) {
+                int normalizedMonths = FieldUtils.safeToInt(totalMonths);
+                result = result.withMonths(normalizedMonths);
+                totalMonths = totalMonths - normalizedMonths;
+            }
+            if (totalMonths != 0) {
+                throw new UnsupportedOperationException(""Unable to normalize as PeriodType is missing either years or months but period has a month/year amount: "" + toString());"
Time 3,junit.framework.ComparisonFailure,"copyPaste
wrapsIf",,"+        if (amount != 0) {
+        }
+        if (years != 0) {
+        }
+        if (weekyears != 0) {
+        }
+        if (months != 0) {
+        }
+        if (weeks != 0) {
+        }
+        if (days != 0) {
+        }
+        if (hours != 0) {
+        }
+        if (minutes != 0) {
+        }
+        if (seconds != 0) {
+        }
+        if (millis != 0) {
+        }","+        if (amount != 0) {
+        }
+        if (years != 0) {
+        }
+        if (weekyears != 0) {
+        }
+        if (months != 0) {
+        }
+        if (weeks != 0) {
+        }
+        if (days != 0) {
+        }
+        if (hours != 0) {
+        }
+        if (minutes != 0) {
+        }
+        if (seconds != 0) {
+        }
+        if (millis != 0) {
+        }"
Time 1,junit.framework.AssertionFailedError,"condBlockExcAdd
condBlockOthersAdd
condBlockRem
expLogicExpand","-                } else if (compare == 0) {
-        if (durationField.isSupported()) {
-            return 1;
-        }","+                if (loopUnitField.isSupported() == false) {
+                    if (lastUnitField.isSupported()) {
+                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" +
+                                        types[i - 1].getName() + "" < "" + loopType.getName());
+                    } else {
+                        throw new IllegalArgumentException(""Types array must not contain duplicate unsupported: "" +
+                                        types[i - 1].getName() + "" and "" + loopType.getName());
+                    }
+                }
+                } else if (compare == 0 && lastUnitField.equals(loopUnitField)) {","+                if (loopUnitField.isSupported() == false) {
+                    if (lastUnitField.isSupported()) {
+                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" +
+                                        types[i - 1].getName() + "" < "" + loopType.getName());
+                    } else {
+                        throw new IllegalArgumentException(""Types array must not contain duplicate unsupported: "" +
+                                        types[i - 1].getName() + "" and "" + loopType.getName());
+                    }
+                }
-                } else if (compare == 0) {
+                } else if (compare == 0 && lastUnitField.equals(loopUnitField)) {
-        if (durationField.isSupported()) {
-            return 1;
-        }"
Time 4,junit.framework.AssertionFailedError,"initFix
singleLine
wrongVarRef","-            Partial newPartial = new Partial(iChronology, newTypes, newValues);","+            Partial newPartial = new Partial(newTypes, newValues, iChronology);","-            Partial newPartial = new Partial(iChronology, newTypes, newValues);
+            Partial newPartial = new Partial(newTypes, newValues, iChronology);"
Mockito 37,junit.framework.AssertionFailedError,condBlockOthersAdd,,"+        if (answer instanceof CallsRealMethods) {
+            validateMockingConcreteClass((CallsRealMethods) answer, invocation);
+        }
+    private void validateMockingConcreteClass(CallsRealMethods answer, Invocation invocation) {
+        if (invocation.getMethod().getDeclaringClass().isInterface()) {
+            reporter.cannotCallRealMethodOnInterface();
+        }
+    }","+        if (answer instanceof CallsRealMethods) {
+            validateMockingConcreteClass((CallsRealMethods) answer, invocation);
+        }
+    private void validateMockingConcreteClass(CallsRealMethods answer, Invocation invocation) {
+        if (invocation.getMethod().getDeclaringClass().isInterface()) {
+            reporter.cannotCallRealMethodOnInterface();
+        }
+    }"
Time 2,java.lang.IllegalArgumentException,"condBlockOthersAdd
condBlockRetAdd
expLogicReduce
missNullCheckP",-                if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {,"+                if (compare < 0) {
+                            if (fieldType.getRangeDurationType() == null) {
+                                break;
+                            }
+        if (durationField.isSupported()) {
+            return 1;
+        }","-                if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {
+                if (compare < 0) {
+                            if (fieldType.getRangeDurationType() == null) {
+                                break;
+                            }
+        if (durationField.isSupported()) {
+            return 1;
+        }"
Time 8,java.lang.IllegalArgumentException,"condBlockExcAdd
constChange
expArithMod
expLogicMod
wrapsMethod","-        if (minutesOffset < 0 || minutesOffset > 59) {
-                minutesOffset = hoursInMinutes - minutesOffset;","+        if (minutesOffset < -59 || minutesOffset > 59) {
+        if (hoursOffset > 0 && minutesOffset < 0) {
+            throw new IllegalArgumentException(""Positive hours must not have negative minutes: "" + minutesOffset);
+        }
+                minutesOffset = hoursInMinutes - Math.abs(minutesOffset);","-        if (minutesOffset < 0 || minutesOffset > 59) {
+        if (minutesOffset < -59 || minutesOffset > 59) {
+        if (hoursOffset > 0 && minutesOffset < 0) {
+            throw new IllegalArgumentException(""Positive hours must not have negative minutes: "" + minutesOffset);
+        }
-                minutesOffset = hoursInMinutes - minutesOffset;
+                minutesOffset = hoursInMinutes - Math.abs(minutesOffset);"
Time 6,junit.framework.AssertionFailedError,"condBlockExcAdd
condBlockOthersAdd
copyPaste
missComp",,"+            LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone));
+            if (cutoverDate.getYear() <= 0) {
+                throw new IllegalArgumentException(""Cutover too early. Must be on or after 0001-01-01."");
+            }
+                        if (iConvertByWeekyear) {
+                            int wyear = iGregorianChronology.weekyear().get(instant);
+                            if (wyear <= 0) {
+                                instant = iGregorianChronology.weekyear().add(instant, -1);
+                            }
+                        } else {
+                            int year = iGregorianChronology.year().get(instant);
+                            if (year <= 0) {
+                                instant = iGregorianChronology.year().add(instant, -1);
+                            }
+                        }
+                        if (iConvertByWeekyear) {
+                            int wyear = iGregorianChronology.weekyear().get(instant);
+                            if (wyear <= 0) {
+                                instant = iGregorianChronology.weekyear().add(instant, -1);
+                            }
+                        } else {
+                            int year = iGregorianChronology.year().get(instant);
+                            if (year <= 0) {
+                                instant = iGregorianChronology.year().add(instant, -1);
+                            }
+                        }","+            LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone));
+            if (cutoverDate.getYear() <= 0) {
+                throw new IllegalArgumentException(""Cutover too early. Must be on or after 0001-01-01."");
+            }
+                        if (iConvertByWeekyear) {
+                            int wyear = iGregorianChronology.weekyear().get(instant);
+                            if (wyear <= 0) {
+                                instant = iGregorianChronology.weekyear().add(instant, -1);
+                            }
+                        } else {
+                            int year = iGregorianChronology.year().get(instant);
+                            if (year <= 0) {
+                                instant = iGregorianChronology.year().add(instant, -1);
+                            }
+                        }
+                        if (iConvertByWeekyear) {
+                            int wyear = iGregorianChronology.weekyear().get(instant);
+                            if (wyear <= 0) {
+                                instant = iGregorianChronology.weekyear().add(instant, -1);
+                            }
+                        } else {
+                            int year = iGregorianChronology.year().get(instant);
+                            if (year <= 0) {
+                                instant = iGregorianChronology.year().add(instant, -1);
+                            }
+                        }"
Time 7,org.joda.time.IllegalFieldValueException,"initFix
notClassified
wrongComp",-        int defaultYear = chrono.year().get(instantLocal);,+        int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);,"+        int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);
-        int defaultYear = chrono.year().get(instantLocal);"
Time 9,junit.framework.AssertionFailedError,"condBlockExcAdd
expArithMod","-            int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);
-                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);
-                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);","+        if (hoursOffset < -23 || hoursOffset > 23) {
+            throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset);
+        }
+            int hoursInMinutes = hoursOffset * 60;
+                minutesOffset = hoursInMinutes - minutesOffset;
+                minutesOffset = hoursInMinutes + minutesOffset;
+        if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) {
+            throw new IllegalArgumentException(""Millis out of range: "" + millisOffset);
+        }","+        if (hoursOffset < -23 || hoursOffset > 23) {
+            throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset);
+        }
-            int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);
+            int hoursInMinutes = hoursOffset * 60;
-                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);
+                minutesOffset = hoursInMinutes - minutesOffset;
-                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);
+                minutesOffset = hoursInMinutes + minutesOffset;
+        if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) {
+            throw new IllegalArgumentException(""Millis out of range: "" + millisOffset);
+        }"
Time 10,org.joda.time.IllegalFieldValueException,"constChange
initFix","-        int[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L));","+    private static final long START_1972 = 2L * 365L * 86400L * 1000L;
+        int[] values = chrono.get(zeroInstance, chrono.set(start, START_1972), chrono.set(end, START_1972));","+    private static final long START_1972 = 2L * 365L * 86400L * 1000L;
-        int[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L));
+        int[] values = chrono.get(zeroInstance, chrono.set(start, START_1972), chrono.set(end, START_1972));"
Time 12,junit.framework.AssertionFailedError,"condBlockRetAdd
copyPaste
missComp
wrapsIfElse","-            yearOfEra,
-            yearOfEra,","+        int era = calendar.get(Calendar.ERA);
+            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),
+        if (date.getTime() < 0) {
+            GregorianCalendar cal = new GregorianCalendar();
+            cal.setTime(date);
+            return fromCalendarFields(cal);
+        }
+        int era = calendar.get(Calendar.ERA);
+            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),
+        if (date.getTime() < 0) {
+            GregorianCalendar cal = new GregorianCalendar();
+            cal.setTime(date);
+            return fromCalendarFields(cal);
+        }","+        int era = calendar.get(Calendar.ERA);
-            yearOfEra,
+            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),
+        if (date.getTime() < 0) {
+            GregorianCalendar cal = new GregorianCalendar();
+            cal.setTime(date);
+            return fromCalendarFields(cal);
+        }
+        int era = calendar.get(Calendar.ERA);
-            yearOfEra,
+            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),
+        if (date.getTime() < 0) {
+            GregorianCalendar cal = new GregorianCalendar();
+            cal.setTime(date);
+            return fromCalendarFields(cal);
+        }"
Time 11,junit.framework.AssertionFailedError,"initFix
notClassified","-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();
-    static {
-        cVerbose.set(Boolean.FALSE);
-    }","+    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>() {
+        protected Boolean initialValue() {
+            return Boolean.FALSE;
+        }
+    };","-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();
-    static {
-        cVerbose.set(Boolean.FALSE);
-    }
+    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>() {
+        protected Boolean initialValue() {
+            return Boolean.FALSE;
+        }
+    };"
Time 14,org.joda.time.IllegalFieldValueException,"condBlockRetAdd
missComp",,"+        if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) {
+            int curMonth0 = partial.getValue(0) - 1;
+            int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1;
+            return set(partial, 0, values, newMonth);
+        }","+        if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) {
+            int curMonth0 = partial.getValue(0) - 1;
+            int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1;
+            return set(partial, 0, values, newMonth);
+        }"
Time 13,junit.framework.ComparisonFailure,"condBlockOthersAdd
expArithMod
wrapsIfElse","-                sum = Math.max(sum, 4);","+                sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4));
+            int bufLen = buf.length();
+                    if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) {
+                        buf.insert(bufLen, '-');
+                    }","-                sum = Math.max(sum, 4);
+                sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4));
+            int bufLen = buf.length();
+                    if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) {
+                        buf.insert(bufLen, '-');
+                    }"
Time 15,junit.framework.AssertionFailedError,condBlockExcAdd,,"+                if (val1 == Long.MIN_VALUE) {
+                    throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
+                }","+                if (val1 == Long.MIN_VALUE) {
+                    throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
+                }"
Time 17,junit.framework.AssertionFailedError,"condBlockRetAdd
expArithMod
expLogicMod
missComp
unwrapMethod
wrongComp","-        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);
-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);
-        if (instantBefore == instantAfter) {
-        long local = convertUTCToLocal(instant);
-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);","+        long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR;
+        long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR;
+        long offsetBefore = getOffset(instantBefore);
+        long offsetAfter = getOffset(instantAfter);
+        if (offsetBefore <= offsetAfter) {
+        long diff = offsetBefore - offsetAfter;
+        long transition = nextTransition(instantBefore);
+        long overlapStart = transition - diff;
+        long overlapEnd = transition + diff;
+        if (instant < overlapStart || instant >= overlapEnd) {
+          return instant;  // not an overlap
+        }
+        long afterStart = instant - overlapStart;
+        if (afterStart >= diff) {
+          return earlierOrLater ? instant : instant - diff;
+        } else {
+          return earlierOrLater ? instant + diff : instant;
+        }","-        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);
-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);
-        if (instantBefore == instantAfter) {
+        long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR;
+        long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR;
+        long offsetBefore = getOffset(instantBefore);
+        long offsetAfter = getOffset(instantAfter);
+        if (offsetBefore <= offsetAfter) {
-        long local = convertUTCToLocal(instant);
-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);
+        long diff = offsetBefore - offsetAfter;
+        long transition = nextTransition(instantBefore);
+        long overlapStart = transition - diff;
+        long overlapEnd = transition + diff;
+        if (instant < overlapStart || instant >= overlapEnd) {
+          return instant;  // not an overlap
+        }
+        long afterStart = instant - overlapStart;
+        if (afterStart >= diff) {
+          return earlierOrLater ? instant : instant - diff;
+        } else {
+          return earlierOrLater ? instant + diff : instant;
+        }"
Time 16,junit.framework.AssertionFailedError,"initFix
singleLine
wrongVarRef","-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);","+            instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));","-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
+            instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));"
Time 20,java.lang.IllegalArgumentException,"condBlockOthersAdd
condBlockRetAdd
missNullCheckN
missNullCheckP","-                    bucket.setZone(DateTimeZone.forID(id));
-                    return position + id.length();","+            String best = null;
+                	if (best == null || id.length() > best.length()) {
+                		best = id;
+                	}
+            if (best != null) {
+                bucket.setZone(DateTimeZone.forID(best));
+                return position + best.length();
+            }","+            String best = null;
-                    bucket.setZone(DateTimeZone.forID(id));
-                    return position + id.length();
+                	if (best == null || id.length() > best.length()) {
+                		best = id;
+                	}
+            if (best != null) {
+                bucket.setZone(DateTimeZone.forID(best));
+                return position + best.length();
+            }"
Time 18,org.joda.time.IllegalFieldValueException,"condBlockExcAdd
missComp
wrapsTryCatch",,"+        try {
+        } catch (IllegalFieldValueException ex) {
+            if (monthOfYear != 2 || dayOfMonth != 29) {
+                throw ex;
+            }
+            instant = iGregorianChronology.getDateTimeMillis
+                (year, monthOfYear, 28,
+                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+            if (instant >= iCutoverMillis) {
+                throw ex;
+            }
+        }","+        try {
+        } catch (IllegalFieldValueException ex) {
+            if (monthOfYear != 2 || dayOfMonth != 29) {
+                throw ex;
+            }
+            instant = iGregorianChronology.getDateTimeMillis
+                (year, monthOfYear, 28,
+                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+            if (instant >= iCutoverMillis) {
+                throw ex;
+            }
+        }"
Time 19,junit.framework.ComparisonFailure,"expLogicMod
singleLine",-        } else if (offsetLocal > 0) {,+        } else if (offsetLocal >= 0) {,"-        } else if (offsetLocal > 0) {
+        } else if (offsetLocal >= 0) {"
Time 21,junit.framework.ComparisonFailure,"condBlockOthersAdd
missNullCheckN
wrapsIf
wrongComp
wrongVarRef","-              byNameKeyCache.put(setLoc[2], new String[] {setLoc[2], setLoc[1]});
-              if (setLoc[2].equals(setLoc[4])) {
-                  byNameKeyCache.put(setLoc[4] + ""-Summer"", new String[] {setLoc[4], setLoc[3]});
-                  byNameKeyCache.put(setLoc[4], new String[] {setLoc[4], setLoc[3]});
-              }
-                break;","+            String[][] zoneStringsEn = DateTimeUtils.getDateFormatSymbols(Locale.ENGLISH).getZoneStrings();
+            String[] setEn = null;
+            for (String[] strings : zoneStringsEn) {
+              if (strings != null && strings.length == 5 && id.equals(strings[0])) {
+                setEn = strings;
+                break;
+              }
+            }
+                break;
+              }
+            }
+            if (setEn != null && setLoc != null) {
+              byNameKeyCache.put(setEn[2], new String[] {setLoc[2], setLoc[1]});
+              if (setEn[2].equals(setEn[4])) {
+                  byNameKeyCache.put(setEn[4] + ""-Summer"", new String[] {setLoc[4], setLoc[3]});
+                  byNameKeyCache.put(setEn[4], new String[] {setLoc[4], setLoc[3]});","+            String[][] zoneStringsEn = DateTimeUtils.getDateFormatSymbols(Locale.ENGLISH).getZoneStrings();
+            String[] setEn = null;
+            for (String[] strings : zoneStringsEn) {
+              if (strings != null && strings.length == 5 && id.equals(strings[0])) {
+                setEn = strings;
+                break;
+              }
+            }
+                break;
+              }
+            }
-              byNameKeyCache.put(setLoc[2], new String[] {setLoc[2], setLoc[1]});
+            if (setEn != null && setLoc != null) {
+              byNameKeyCache.put(setEn[2], new String[] {setLoc[2], setLoc[1]});
-              if (setLoc[2].equals(setLoc[4])) {
-                  byNameKeyCache.put(setLoc[4] + ""-Summer"", new String[] {setLoc[4], setLoc[3]});
+              if (setEn[2].equals(setEn[4])) {
+                  byNameKeyCache.put(setEn[4] + ""-Summer"", new String[] {setLoc[4], setLoc[3]});
-                  byNameKeyCache.put(setLoc[4], new String[] {setLoc[4], setLoc[3]});
-              }
-                break;
+                  byNameKeyCache.put(setEn[4], new String[] {setLoc[4], setLoc[3]});"
Time 22,junit.framework.AssertionFailedError,"initFix
notClassified
wrongComp","-        this(duration, null, null);","+        super();
+        iType = PeriodType.time();
+        int[] values = ISOChronology.getInstanceUTC().get(this, duration);
+        iType = PeriodType.standard();
+        iValues = new int[8];
+        System.arraycopy(values, 0, iValues, 4, 4);","-        this(duration, null, null);
+        super();
+        iType = PeriodType.time();
+        int[] values = ISOChronology.getInstanceUTC().get(this, duration);
+        iType = PeriodType.standard();
+        iValues = new int[8];
+        System.arraycopy(values, 0, iValues, 4, 4);"
Time 23,junit.framework.ComparisonFailure,"constChange
initFix","-            map.put(""IET"", ""America/Indianapolis"");
-            map.put(""AGT"", ""America/Buenos_Aires"");
-            map.put(""WET"", ""Europe/London"");
-            map.put(""ECT"", ""Europe/Paris"");
-            map.put(""EET"", ""Europe/Bucharest"");
-            map.put(""MET"", ""Asia/Tehran"");
-            map.put(""IST"", ""Asia/Calcutta"");
-            map.put(""VST"", ""Asia/Saigon"");","+            map.put(""WET"", ""WET"");
+            map.put(""CET"", ""CET"");
+            map.put(""MET"", ""CET"");
+            map.put(""ECT"", ""CET"");
+            map.put(""EET"", ""EET"");
+            map.put(""IET"", ""America/Indiana/Indianapolis"");
+            map.put(""AGT"", ""America/Argentina/Buenos_Aires"");
+            map.put(""IST"", ""Asia/Kolkata"");
+            map.put(""VST"", ""Asia/Ho_Chi_Minh"");","+            map.put(""WET"", ""WET"");
+            map.put(""CET"", ""CET"");
+            map.put(""MET"", ""CET"");
+            map.put(""ECT"", ""CET"");
+            map.put(""EET"", ""EET"");
-            map.put(""IET"", ""America/Indianapolis"");
+            map.put(""IET"", ""America/Indiana/Indianapolis"");
-            map.put(""AGT"", ""America/Buenos_Aires"");
+            map.put(""AGT"", ""America/Argentina/Buenos_Aires"");
-            map.put(""WET"", ""Europe/London"");
-            map.put(""ECT"", ""Europe/Paris"");
-            map.put(""EET"", ""Europe/Bucharest"");
-            map.put(""MET"", ""Asia/Tehran"");
-            map.put(""IST"", ""Asia/Calcutta"");
+            map.put(""IST"", ""Asia/Kolkata"");
-            map.put(""VST"", ""Asia/Saigon"");
+            map.put(""VST"", ""Asia/Ho_Chi_Minh"");"
Time 25,junit.framework.ComparisonFailure,"condBlockOthersAdd
condBlockRetAdd
missComp",,"+        } else if (offsetLocal > 0) {
+            long prev = previousTransition(instantAdjusted);
+            if (prev < instantAdjusted) {
+                int offsetPrev = getOffset(prev);
+                int diff = offsetPrev - offsetLocal;
+                if (instantAdjusted - prev <= diff) {
+                    return offsetPrev;
+                }
+            }","+        } else if (offsetLocal > 0) {
+            long prev = previousTransition(instantAdjusted);
+            if (prev < instantAdjusted) {
+                int offsetPrev = getOffset(prev);
+                int diff = offsetPrev - offsetLocal;
+                if (instantAdjusted - prev <= diff) {
+                    return offsetPrev;
+                }
+            }"
Time 26,junit.framework.ComparisonFailure,"copyPaste
wrongMethodRef","-               return iZone.convertLocalToUTC(localInstant, false);
-               return iZone.convertLocalToUTC(localInstant, false);
-                return iZone.convertLocalToUTC(localInstant, false);
-            long result = iZone.convertLocalToUTC(localInstant, false);
-            return iZone.convertLocalToUTC(localInstant, false);
-                return iZone.convertLocalToUTC(localInstant, false);
-                return iZone.convertLocalToUTC(localInstant, false);","+               return iZone.convertLocalToUTC(localInstant, false, instant);
+               return iZone.convertLocalToUTC(localInstant, false, instant);
+                return iZone.convertLocalToUTC(localInstant, false, instant);
+            long result = iZone.convertLocalToUTC(localInstant, false, instant);
+            return iZone.convertLocalToUTC(localInstant, false, instant);
+                return iZone.convertLocalToUTC(localInstant, false, instant);
+                return iZone.convertLocalToUTC(localInstant, false, instant);","-               return iZone.convertLocalToUTC(localInstant, false);
+               return iZone.convertLocalToUTC(localInstant, false, instant);
-               return iZone.convertLocalToUTC(localInstant, false);
+               return iZone.convertLocalToUTC(localInstant, false, instant);
-                return iZone.convertLocalToUTC(localInstant, false);
+                return iZone.convertLocalToUTC(localInstant, false, instant);
-            long result = iZone.convertLocalToUTC(localInstant, false);
+            long result = iZone.convertLocalToUTC(localInstant, false, instant);
-            return iZone.convertLocalToUTC(localInstant, false);
+            return iZone.convertLocalToUTC(localInstant, false, instant);
-                return iZone.convertLocalToUTC(localInstant, false);
+                return iZone.convertLocalToUTC(localInstant, false, instant);
-                return iZone.convertLocalToUTC(localInstant, false);
+                return iZone.convertLocalToUTC(localInstant, false, instant);"
Time 24,junit.framework.AssertionFailedError,condBlockOthersAdd,,"+            if (resetFields) {
+                for (int i = 0; i < count; i++) {
+                    millis = savedFields[i].set(millis, i == (count - 1));
+                }
+            }","+            if (resetFields) {
+                for (int i = 0; i < count; i++) {
+                    millis = savedFields[i].set(millis, i == (count - 1));
+                }
+            }"
Time 27,java.lang.IllegalArgumentException,"missNullCheckP
wrapsIf",,"+            if (sep.iAfterParser == null && sep.iAfterPrinter == null) {
+            }","+            if (sep.iAfterParser == null && sep.iAfterPrinter == null) {
+            }"
